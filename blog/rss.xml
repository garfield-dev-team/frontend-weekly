<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/">
    <channel>
        <title>Frontend Weekly Blog</title>
        <link>https://your-docusaurus-test-site.com/frontend-weekly/blog</link>
        <description>Frontend Weekly Blog</description>
        <lastBuildDate>Mon, 12 Dec 2022 00:00:00 GMT</lastBuildDate>
        <docs>https://validator.w3.org/feed/docs/rss2.html</docs>
        <generator>https://github.com/jpmonette/feed</generator>
        <item>
            <title><![CDATA[置顶内容]]></title>
            <link>https://your-docusaurus-test-site.com/frontend-weekly/blog/welcome</link>
            <guid>welcome</guid>
            <pubDate>Mon, 12 Dec 2022 00:00:00 GMT</pubDate>
            <description><![CDATA[⭐️ 每周更新优质技术文章，欢迎点赞关注！]]></description>
            <content:encoded><![CDATA[<p>⭐️ 每周更新优质技术文章，欢迎点赞关注！</p><h2>TypeScript 工程化方案</h2><ul><li>⭐️ ⭐️ <a href="https://zhuanlan.zhihu.com/p/403970666">2021 年 TypeScript + React 工程化指南</a></li><li>⭐️ ⭐️ <a href="https://juejin.cn/post/7039583726375796749#heading-22">会写 TypeScript 但你真的会 TS 编译配置吗？</a></li><li>🌛 <a href="https://juejin.cn/post/6844904102355271694">【开源】一个 React + TS 项目模板</a><ul><li>一种是使用 ts-loader + babel-loader + fork-ts-checker-webpack-plugin 通过 typescript 进行编译和类型检查</li><li>另一种是 babel-loader + @babel/preset-typescript 使用 babel 进行编译，typescript 只负责类型检查（babel 7 以上）</li></ul></li><li>🌛 <a href="https://juejin.cn/post/6999807899149008910">2021年从零开发前端项目指南</a></li><li><a href="https://juejin.cn/post/6844904052094926855">Webpack 转译 Typescript 现有方案</a></li><li>🌛 <a href="https://segmentfault.com/a/1190000015315545">使用ESLint+Prettier来统一前端代码风格</a></li><li>🌛 <a href="https://segmentfault.com/a/1190000009546913">用 husky 和 lint-staged 构建超溜的代码检查工作流</a></li></ul><h2>TS 高级技巧</h2><ul><li>🌛 <a href="https://juejin.cn/post/7007251289721536543">TypeScript是如何工作的</a></li><li>⭐️ <a href="https://juejin.cn/post/6964692485415108645">TypeScript 高级用法</a></li><li><a href="https://juejin.cn/post/6844904055039344654">TS 常见问题整理（60多个，持续更新ing）</a></li><li><a href="https://juejin.cn/post/6994102811218673700">Ts高手篇：22个示例深入讲解Ts最晦涩难懂的高级类型工具</a></li></ul><h2>TS &amp;&amp; 框架</h2><ul><li>⭐️ ⭐️ <a href="https://juejin.cn/post/6952696734078369828">React + TypeScript实践</a></li><li><a href="https://juejin.cn/post/7021674818621669389">如何优雅地在 React 中使用TypeScript，看这一篇就够了！</a></li><li>⭐️ <a href="https://juejin.cn/post/6844903865255477261">Vue3.0 前的 TypeScript 最佳入门实践</a><ul><li>虽然不是 Vue3 但是也推荐看下</li></ul></li></ul><h2>前端框架</h2><ul><li><a href="https://juejin.cn/post/7047705995534925832">盘点掘金 2021 高赞 Vue 文章</a></li><li><a href="https://juejin.cn/post/7047690546417565733">盘点掘金 2021 高赞 React 文章</a></li><li><a href="https://juejin.cn/post/7047153016771706916">盘点掘金 2021 点赞高达 6000，收藏过万的文章</a></li><li>⭐️ <a href="https://juejin.cn/post/6922641008106668045">揭秘 Vue.js 九个性能优化技巧</a></li><li>🌛 <a href="https://juejin.cn/post/7005880217684148231">我在项目中用实际用到的22个Vue优化技巧</a></li><li>⭐️ <a href="https://juejin.cn/post/6933018383961194509">你可能不知道的流式 React Hooks（关于组织代码的最佳实践）</a></li><li>⭐️ <a href="https://juejin.cn/post/7025524870842679310#heading-58">从 16 个方向逐步搭建基于 vue3 的前端架构</a></li><li>⭐️ <a href="https://juejin.cn/post/6874007172578033677">34条我能告诉你的Vue之实操篇</a></li><li>🌛 <a href="https://zhuanlan.zhihu.com/p/461844358">React 体系下关于 Mobx 与 Redux 的一些思考</a></li><li>🌛 <a href="https://mp.weixin.qq.com/s/aOapwk4_qi8tNM7vaa7jGA">使用 React&amp;Mobx 的几个最佳实践</a></li><li>⭐️ <a href="https://juejin.cn/post/6995834232350179336">当设计模式遇上 Hooks</a></li><li>⭐️ ⭐️ <a href="https://juejin.cn/post/6844903985338400782">React Hooks 详解 【近 1W 字】+ 项目实战</a></li><li><a href="https://juejin.cn/post/6989022564043456543">「React进阶」只用两个自定义 Hooks 就能替代 React-Redux ?</a></li><li><a href="https://juejin.cn/post/6950063294270930980">「React进阶」 React全部api解读+基础实践大全(夯实基础2万字总结)</a></li><li><a href="https://juejin.cn/post/6963053793613185031">「React进阶」探案揭秘六种React‘灵异’现象</a></li><li><a href="https://juejin.cn/post/6944863057000529933">「react进阶」一文吃透react-hooks原理</a></li></ul><h2>开源项目</h2><ul><li>⭐️ <a href="https://github.com/streamich/react-use">react-use - 一个 React Hooks 库</a></li><li><a href="https://github.com/tannerlinsley/react-query">react-query - 用于获取数据、缓存、异步更新状态的 hook</a></li><li><a href="https://github.com/prisma/prisma">prisma - 下一代 Nodejs ORM 工具，支持各种数据库</a></li><li><a href="https://github.com/withastro/astro">astro - 静态站点构建工具</a></li><li><a href="https://github.com/pmndrs/zustand">zustand - 小型、快速可扩展的状态管理解决方案</a></li><li><a href="https://github.com/tauri-apps/tauri">tauri - 将前端项目打包为桌面应用，用于替代 electron</a></li></ul><h2>业务成长</h2><ul><li>⭐️ <a href="https://juejin.cn/post/6965675185890394119">精读《前端职业规划 - 2021 年》</a></li><li>⭐️ <a href="https://juejin.cn/post/7034419410706104356">2022年如何成为一名优秀的大前端Leader？</a></li><li>⭐️ ⭐️ <a href="https://juejin.cn/post/6906468062943182862#heading-8">初级工程师如何快速成长和寻求突破</a></li><li><a href="https://mp.weixin.qq.com/s/NRqhJax8e6K8LMCNZSSozA">年底了，你是如何做工作汇报的？</a></li><li><a href="https://juejin.cn/post/7041713124210114567">在政采云如何写前端技术方案文档</a></li><li><a href="https://juejin.cn/post/7017643726944108558">如何编写前端设计文档</a></li><li>⭐️ <a href="https://juejin.cn/post/6901845776880795662#heading-0">理清思路，前端技术调研到底应该怎么做？</a></li><li><a href="https://juejin.cn/post/6869548364640288781">从实习到入职：与你分享我在政采云的工作和成长</a></li></ul><h2>Git 相关</h2><ul><li><a href="https://juejin.cn/post/7046409685561245733">利用好 git bisect 这把利器，帮助你快速定位疑难 bug</a></li><li>⭐️ <a href="https://juejin.cn/post/7024043015794589727">前端架构师的 git 功力，你有几成火候？</a></li><li>⭐️ <a href="https://segmentfault.com/a/1190000040712052">两条命令让你的git自动变基</a></li><li>⭐️ ⭐️ <a href="https://juejin.cn/post/6844904191203213326">多年 Git 使用心得 &amp; 常见问题整理</a></li><li>🌛 <a href="https://juejin.cn/post/7000186205224566791">为什么 husky 放弃了传统的 JS 配置</a></li><li>⭐️ <a href="https://juejin.cn/post/6844904036068491278">你可能已经忽略的git commit规范</a></li><li><a href="https://gitmoji.dev/">gitmoji: An emoji guide for your commit messages</a></li></ul><h2>源码系列</h2><ul><li>⭐️ <a href="https://juejin.cn/post/6982004709145968677">[建议收藏] 你想知道的Vue3核心源码这里都有</a></li><li>⭐️ <a href="https://juejin.cn/post/7048970987500470279">六千字详解！vue3 响应式是如何实现的？</a></li><li>⭐️ ⭐️ <a href="https://juejin.cn/post/7019185205336342542">Redux通关简洁攻略 -- 看这一篇就够了！</a></li><li>⭐️ <a href="https://juejin.cn/post/6978654109893132318">手写系列-实现一个铂金段位的 React</a></li><li>⭐️ <a href="https://juejin.cn/post/7010539227284766751">React 运行时优化方案的演进</a></li><li>⭐️ <a href="https://juejin.cn/post/6990974525273800712">带你快速手写一个简易版vue了解vue响应式</a></li><li><a href="https://juejin.cn/post/6977363265965785102">2021年，让我们手写一个mini版本的vue2.x和vue3.x框架</a></li><li><a href="https://juejin.cn/post/6846687602679119885">Vue(v2.6.11)万行源码生啃，就硬刚！</a></li><li><a href="https://juejin.cn/post/6992018709439053837">尤雨溪国外教程：亲手带你写个简易版的Vue！</a></li><li><a href="https://codepen.io/collection/DkxpbE?cursor=ZD0wJm89MCZwPTEmdj00">Vue 3 Workshop Code Samples</a></li><li>⭐️ <a href="https://juejin.cn/post/6997965021401579556">diff 算法深入一下？</a></li><li>⭐️ <a href="https://juejin.cn/post/6997943192851054606">Vue 3.2 发布了，那尤雨溪是怎么发布 Vue.js 的？</a></li><li>⭐️ <a href="https://juejin.cn/post/6994976281053888519">初学者也能看懂的 Vue3 源码中那些实用的基础工具函数</a></li></ul><h2>Webpack 系列</h2><ul><li><a href="https://juejin.cn/post/6937125495439900685">Webpack 案例 —— vue-loader 原理分析</a><ul><li>通过编写一个 plugin，在预处理阶段通过插件 apply 函数动态修改 webpack 配置，注入 vue-loader 专用的 rules</li></ul></li><li><a href="https://juejin.cn/post/7047777251949019173">超硬核｜带你畅游在 Webpack 插件开发者的世界</a></li><li>⭐️ ⭐️ <a href="https://juejin.cn/post/7023242274876162084">【万字】透过分析 webpack 面试题，构建 webpack5.x 知识体系</a></li><li>⭐️ <a href="https://juejin.cn/post/7021729340945596424">Webpack 原理系列十：HMR 原理全解析</a></li><li><a href="https://mp.weixin.qq.com/s/gwHwVxA4zh59SBvq-onM-g">Webpack5 实践 - 构建效率倍速提升！</a></li><li>🌛 <a href="https://mp.weixin.qq.com/s/mpF6W-4dElu0UPed03oJQw">Webpack 性能系列一: 使用 Cache 提升构建性能</a></li><li>🌛 <a href="https://juejin.cn/post/6910893471339708429">我是如何将网页性能提升5倍的 — 构建优化篇</a></li><li>⭐️ ⭐️ <a href="https://juejin.cn/post/6996816316875161637">学习 Webpack5 之路（优化篇）- 近 7k 字</a></li><li>⭐️ <a href="https://juejin.cn/post/6844903912588181511">手把手带你入门 Webpack4</a></li><li>⭐️ ⭐️ <a href="https://juejin.cn/post/6949040393165996040">[<!-- -->万字总结<!-- -->]<!-- --> 一文吃透 Webpack 核心原理</a></li></ul><h2>Vite 系列</h2><ul><li><a href="https://juejin.cn/post/6979932627465666568">下一代前端构建工具 - Vite 2.x 源码级分析</a></li><li><a href="https://juejin.cn/post/6956564266812571656">面向未来的前端构建工具 - Vite ⚡️原理分析</a></li></ul><h2>Monorepo 系列</h2><ul><li><a href="https://juejin.cn/post/7051929587852247077">年终盘点：2022基于Monorepo的首个大趋势-TurboRepo</a></li><li><a href="https://juejin.cn/post/7043998041786810398">One For All：基于pnpm + lerna + typescript的最佳项目实践 - 理论篇</a></li><li><a href="https://juejin.cn/post/7029262501833359368">【我要做开源】Vue DevUI开源指南08：Monorepo改造</a></li><li><a href="https://juejin.cn/post/6972139870231724045">Monorepo 的这些坑，我们帮你踩过了！</a></li></ul><h2>Rollup 系列</h2><ul><li><a href="https://juejin.cn/post/6869551115420041229">一文带你快速上手Rollup</a></li></ul><h2>前端工程化</h2><ul><li><a href="https://juejin.cn/post/7057114641507287048">easy-serverless 功能分析</a></li><li>⭐️ <a href="https://juejin.cn/post/7046204235226021901">基于 Next.js 的 SSR/SSG 方案了解一下？</a></li><li>🌛 <a href="https://juejin.cn/post/7029512357428592648">前端架构师神技，三招统一团队代码风格</a></li><li>🌛 <a href="https://juejin.cn/post/6844904110601273357">手把手教你搭建一个灰度发布环境</a></li><li>⭐️ <a href="https://mp.weixin.qq.com/s/3TKcUeoyzXvH3MGVI6Dj9A">ESM 与 CJS 的 Interop 来世今生</a></li><li>⭐️ <a href="https://www.zhihu.com/question/493891614/answer/2269197391">2022 前端技术领域会有哪些新的变化？</a></li><li>🌛 <a href="https://segmentfault.com/a/1190000040496020">前端构建这十年</a></li></ul><h2>前端性能优化</h2><ul><li>⭐️ <a href="https://juejin.cn/post/7048260643589193765">2022 年的 CSS</a></li><li>⭐️ <a href="https://juejin.cn/post/7054931603323093022">如何编写防御式的 CSS</a></li><li>⭐️ <a href="https://zhuanlan.zhihu.com/p/396010993">前端 Code Review 不完全指北(万字长文，50+case)</a></li><li>🌛 <a href="https://juejin.cn/post/7020212914020302856">写在 2021 的前端性能优化指南</a></li><li><a href="https://juejin.cn/post/7000728875676205086">深入浅出 Performance 工具 &amp; API</a></li><li><a href="https://juejin.cn/post/6904582930174705677">使用 Performance 看看浏览器在做什么</a></li></ul><h2>前端组件库实战</h2><ul><li>⭐️ <a href="https://juejin.cn/post/7021528826798669854">尤大都推荐的组件库是如何开发出来的？</a></li><li>⭐️ <a href="https://juejin.cn/post/6983854006124675108">每个前端都值得拥有自己的组件库，就像每个夏天都拥有西瓜🍉</a></li><li>⭐️ <a href="https://juejin.cn/post/6930879590554402830">Vue3组件库工程化实战 --Element3</a></li></ul><h2>Node.js 系列</h2><ul><li>⭐️ ⭐️ <a href="https://juejin.cn/post/6887961766170066951">大厂是如何用DevCloud流水线实现自动化部署Web应用的？</a></li><li>⭐️ ⭐️ <a href="https://juejin.cn/post/6902659492161421325">手把手教你使用Rollup打包 📦 并发布自己的工具库 🔧</a></li><li>🌛 <a href="https://zhuanlan.zhihu.com/p/461945753">Node 案发现场揭秘 —— 未定义 “window” 对象引发的 SSR 内存泄露</a></li><li>🌛 <a href="https://cnodejs.org/topic/58eb5d378cda07442731569f">轻松排查线上Node内存泄漏问题</a></li><li>⭐️ <a href="https://juejin.cn/post/7044344538969669663">NodeJS加解密之Crypto</a></li><li>🌛 <a href="https://github.com/google/zx">zx - 谷歌开发的命令行脚本工具</a></li><li>🌛 <a href="https://github.com/node-fetch/node-fetch">node-fetch - node 环境下进行网络请求</a></li><li>⭐️ <a href="https://juejin.cn/post/6971770846872338439">浅析 NodeJS 多进程和集群</a></li><li>⭐️ <a href="https://github.com/privatenumber/tasuku">Tasuku - 面向 Node 的最小任务运行器</a></li><li>🌛 <a href="https://juejin.cn/post/7008504029277847565">Node.js的底层原理</a></li><li>⭐️ <a href="https://mp.weixin.qq.com/s/Gcx6E4cYo6WPB8PLI72NWg">认真写了个快速创建 Node 服务的CLI，看看对小伙伴们有帮忙吗？</a><ul><li>项目地址：<a href="https://github.com/koala-coding/create-bff-service-cli">https://github.com/koala-coding/create-bff-service-cli</a></li></ul></li></ul><h2>前端编译</h2><ul><li><a href="https://juejin.cn/post/7041021350114230285">V8 编译浅谈</a></li><li>⭐️ <a href="https://juejin.cn/post/7057354419888717855">编译技术在前端的实践（二）—— Antlr 及其应用</a></li><li>⭐️ <a href="https://juejin.cn/post/6989509925844041742">编译技术在前端的实践（一）—— 编译原理基础</a></li><li><a href="https://juejin.cn/post/6953963506693570573">前端也要懂编译：AST 从入门到上手指南</a></li></ul><h2>文件上传</h2><ul><li>⭐️ <a href="https://juejin.cn/post/6844904046436843527">字节跳动面试官：请你实现一个大文件上传和断点续传</a></li><li>⭐️ <a href="https://juejin.cn/post/6990283221170651149">从零开始手写一个「开箱即用的大文件分片上传库」</a></li><li><a href="https://juejin.cn/post/6992007156320960542">5000字带你全面深入理解JS中的Stream API｜8月更文挑战</a></li></ul><h2>网络相关</h2><ul><li>推荐看看 QUIC 101 视频以及 <a href="https://courses.cs.washington.edu/courses/cse550/20au/papers/CSE550.quic.pdf">The QUIC transport protocol: design and Internet-scale deployment</a> 论文</li><li>⭐️ <a href="https://segmentfault.com/a/1190000024523772">一文彻底搞懂加密、数字签名和数字证书！</a></li><li>⭐️ <a href="https://juejin.cn/post/6944420222757503006">一个Response Header引发的血案(包含CDN的相关概念)</a></li></ul><h2>操作系统</h2><ul><li><a href="https://juejin.cn/post/6917096816118857736">6w字搞定Linux基本操作，建议收藏</a></li><li><a href="https://juejin.cn/post/6844904080972709901">半小时搞会 CentOS 入门必备基础知识</a></li><li><a href="https://juejin.cn/post/6875323565479034894">手摸手带你 Docker 从入门到实践</a></li></ul><h2>机器学习</h2><ul><li><a href="https://www.bilibili.com/video/BV1cD4y1D7uR">《深入理解计算机系统》- bilibili</a></li><li><a href="https://www.bilibili.com/video/BV1mb4y1d7K7">《计算机网络自顶向下方法》- bilibili</a><ul><li>这本书重点章节是第2、3、4、5、6章，其他章节可以跳过</li></ul></li><li>学习资源<ul><li><a href="https://github.com/ossu/computer-science">https://github.com/ossu/computer-science</a></li><li><a href="https://github.com/Snailclimb/JavaGuide">https://github.com/Snailclimb/JavaGuide</a></li><li><a href="https://github.com/QSCTech/zju-icicles">https://github.com/QSCTech/zju-icicles</a></li></ul></li><li><a href="https://www.bilibili.com/video/BV1Vt411z7wy">一天学会 MySQL 数据库</a></li><li><a href="https://www.bilibili.com/video/BV1FT4y1E74V">吴恩达《深度学习》</a></li><li><a href="https://www.bilibili.com/video/BV1qK4y1479r">推荐系统算法基础+综合项目实战</a><ul><li>再就是一些我认为很优秀的开源项目：</li><li><a href="https://github.com/zhongqiangwu960812/AI-RecommenderSystem">https://github.com/zhongqiangwu960812/AI-RecommenderSystem</a></li><li><a href="https://github.com/ZiyaoGeng/Recommender-System-with-TF2.0">https://github.com/ZiyaoGeng/Recommender-System-with-TF2.0</a></li></ul></li><li>参考：<a href="https://mp.weixin.qq.com/s/YbwQAPIEkihO7XzVvrlDCg">万字入门推荐系统！</a></li><li><a href="https://juejin.cn/post/7013674501116264484">说一说Web端侧AI</a></li><li><a href="https://juejin.cn/post/6964335363787620383">机器学习初探-线性回归</a></li><li><a href="https://juejin.cn/post/6951340421658181646">机器学习进阶 - 深入思考逻辑回归</a></li></ul><h2>Java 相关</h2><ul><li><a href="https://juejin.cn/post/7031047868806873096">使用 @Transactional 时常犯的N种错误</a></li><li><a href="https://juejin.cn/post/6984974277573836830">Spring Boot 2.x基础教程：使用@Scheduled实现定时任务</a></li><li><a href="https://juejin.cn/post/7007642025264676871">Spring Boot中使用@Async实现异步调用，加速任务的执行！</a></li><li><a href="https://github.com/fuzhengwei/CodeGuide">CodeGuide | 程序员编码指南</a></li><li><a href="https://github.com/fuzhengwei/small-spring">🌱 Spring 手撸专栏 - 易学、好写、能懂！</a></li></ul><h2>Golang 学习</h2><ul><li>⭐️ <a href="https://www.youtube.com/watch?v=YS4e4q9oBaU">Learn Go Programming - Golang Tutorial for Beginners</a></li><li><a href="https://github.com/wumansgy/GoAndBlockChainStudy">https://github.com/wumansgy/GoAndBlockChainStudy</a></li><li><a href="https://zhuanlan.zhihu.com/p/437626980">Golang设计模式总结</a></li><li><a href="https://zhuanlan.zhihu.com/p/377834750">手把手教你如何进行 Golang 单元测试</a></li><li><a href="https://zhuanlan.zhihu.com/p/267341653">Golang 单元测试指引</a></li><li>⭐️ <a href="https://juejin.cn/post/7041846339189080101">使用Golang、Gin和React、esbuild开发的Blog</a></li><li>⭐️ <a href="https://github.com/go-gorm/gorm">gorm - Golang 的出色 ORM 库</a></li><li>⭐️ <a href="https://github.com/gofiber/fiber">fiber：受到 Express 启发的 Web 应用框架</a></li><li><a href="https://go.dev/">Golang 官方文档</a></li><li><a href="https://zhuanlan.zhihu.com/p/426368274">Golang 编程思维和工程实战</a></li><li>⭐️ <a href="https://gobyexample.com/">Go by example</a></li></ul><h2>面试相关</h2><ul><li><a href="https://github.com/ConardLi/awesome-coding-js">JS 数据结构与算法 - awesome-coding-js</a></li><li><a href="https://github.com/trekhleb/javascript-algorithms">JavaScript Algorithms and Data Structures</a></li><li><a href="https://juejin.cn/post/7023208826472005668">JavaScript算法基础及面试总结（1w1字）</a></li><li>⭐️ <a href="https://juejin.cn/post/6844903929705136141">如何写出一个惊艳面试官的深拷贝?</a></li><li>⭐️ <a href="https://juejin.cn/post/6844904118704668685">面了几个说自己精通 Vue 的同学</a></li><li><a href="https://blog.csdn.net/xgangzai/article/details/120375992">高频react面试题20道（附详解）</a></li><li><a href="https://juejin.cn/post/6844903885488783374">【1 月最新】前端 100 问：能搞懂 80% 的请把简历给我</a></li></ul><h2>前端测试</h2><ul><li><a href="https://juejin.cn/post/6943430853972852750">那些年错过的React组件单元测试（上）</a></li><li><a href="https://juejin.cn/post/6946008649026240519">那些年错过的React组件单元测试（下）</a></li><li><a href="https://juejin.cn/post/6999445868550029319">前端测试集锦——如何写好前端测试保证代码质量？</a></li></ul><h2>开发环境相关</h2><ul><li><a href="https://juejin.cn/post/7035448197883363359">【手把手】学会VS Code&quot;任务&quot;神技，成为项目组最靓的崽！</a></li><li><a href="https://juejin.cn/post/7019183422320934948">聊聊开发日常的效率提升工具（全）</a></li><li><a href="https://juejin.cn/post/6844904193828880391">打造舒适搬砖环境，这些是我最想推介的桌面好物</a></li><li><a href="https://juejin.cn/post/6844904012920127495">干货满满！推介几款 Mac 下非常好用的软件（第一弹）</a></li><li><a href="https://juejin.cn/post/6844904031685443592">干货满满！推介几款 Mac 下非常好用的软件（第二弹）</a></li></ul><h2>📒 掘金大佬汇总</h2><ul><li>Vue 源码、响应式机制：<a href="https://juejin.cn/user/2330620350708823/posts">ssh</a> 、<a href="https://juejin.cn/user/2137106333044861/posts">黄轶</a></li><li>React 进阶系列：<a href="https://juejin.cn/user/2418581313687390/posts">我不是外星人</a></li><li>Webpack 相关：<a href="https://juejin.cn/user/1820446985555544/posts">Tecvan</a></li><li>设计模式：<a href="https://juejin.cn/user/3544481219495806/posts">DYBOY</a></li><li>手写源码、设计模式：<a href="https://juejin.cn/user/2295436011645655/posts">蒋鹏飞</a></li><li>Webpack5、设计模式：<a href="https://juejin.cn/user/4300945218607197">清汤饺子</a></li><li>源码分析：若川</li><li>工程化知识卡片：<a href="https://juejin.cn/user/1556564164489389/posts">shanyue</a></li><li>个人服务器运维指南：<a href="https://shanyue.tech/op/#%E9%A2%84%E8%A7%88">shanyue</a></li><li>CSS 各种特效：<a href="https://juejin.cn/user/2330620350437678/posts">chokcoco</a></li><li>Golang 相关：<a href="https://zhuanlan.zhihu.com/p/340814811">腾讯技术工程</a></li><li>前端装逼技巧108式：<a href="https://segmentfault.com/u/king_hcj">独钓寒江雪</a></li><li>前端九条 bug 分享：<a href="https://segmentfault.com/u/lulu_up">lulu_up</a></li><li>Vue3 源码共读：<a href="https://www.bilibili.com/video/BV1bS4y1T7ng">前端杨村长</a></li><li>前端工程化、学习 Golang：洛竹</li><li>Node.js 相关：五月君</li></ul><h2>📒 待学习内容</h2><ul><li><a href="https://juejin.cn/post/7017360824939315207">babel源码详解-v1.7.8</a></li><li><a href="https://juejin.cn/post/6844904094079926286">最简实现Promise，支持异步链式调用（20行）</a></li><li><a href="https://juejin.cn/post/6844904116913700877">手写一个Promise/A+,完美通过官方872个测试用例</a></li><li><a href="https://juejin.cn/post/6889247428797530126">我在工作中写React，学到了什么？性能优化篇</a></li><li><a href="https://juejin.cn/post/6844903783005175815">如何利用lerna管理模块</a></li><li><a href="https://juejin.cn/post/6969544464113074189">基于 lerna 的多包 JavaScript 项目搭建维护</a></li><li><a href="https://juejin.cn/post/6844903896767283207#heading-5">React性能优化小贴士</a></li><li><a href="https://juejin.cn/post/6844903929726107655">神奇的lambda表达式——函数式编程必学</a></li><li><a href="https://juejin.cn/post/6844903954002739213">npm进阶——如何拥有自己的包和流程自动化</a></li><li><a href="https://juejin.cn/post/6844904162124103693">React Hooks的花样玩法</a><ul><li>useDark，useClickOutside，全局状态管理</li></ul></li><li><a href="https://juejin.cn/post/6844903845227659271">正则表达式不要背</a></li><li><a href="https://juejin.cn/post/6844903825145511950">我们或许不需要 classnames 这个库</a></li><li><a href="https://juejin.cn/post/7014431215302213668">国庆爆肝，用vite+vue3+ts实现一个网页版的typora！</a></li><li><a href="https://juejin.cn/post/6982192362583752741">手摸手教你使用最新版husky(v7.0.1)让代码更优雅规范</a></li><li><a href="https://juejin.cn/post/7015476516196712462">快速入手Electron，拥有一个自己的桌面应用</a></li><li><a href="https://juejin.cn/post/6945236994247098381">在大厂是如何高效组织 npm script 的</a></li><li><a href="https://juejin.cn/post/6940042028243746823">前端开发者周刊第三期：各大厂 webpack5 实践</a></li><li><a href="https://juejin.cn/post/6937176680251424775#heading-7">【译】下一代前端构建工具 ViteJS 中英双语字幕 ｜ 技术点评</a></li><li>⭐️ <a href="https://juejin.cn/post/6924258563862822919">Webpack5 新特性业务落地实战</a></li><li>⭐️ <a href="https://webpack.docschina.org/guides/development/#choosing-a-development-tool">Webpack 官方开发指南</a></li><li><a href="https://mp.weixin.qq.com/s/P3foOrcu4StJDGdX9xavng">构建效率大幅提升，webpack5 在企鹅辅导的升级实践</a></li><li><a href="https://mp.weixin.qq.com/s/ZP2IigNVSIZKGuYxNYOYgw">如何利用 monorepo 策略管理代码？</a></li><li><a href="https://juejin.cn/post/6924854598268108807">All in one：项目级 monorepo 策略最佳实践</a></li><li><a href="https://juejin.cn/post/7007252464726458399">一顿操作，我把 Table 组件性能提升了十倍</a></li></ul><h2>📒 小目标</h2><ul><li>Vue 3.x 源码；</li><li>Vuex 4.x 源码；</li><li>Vue-Router 源码；</li><li>搭建脚手架工具（Webpack5 新特性实践）；</li><li>VS Code extension ；</li><li>cocos 游戏开发；</li><li>手写 redux 源码；</li><li>手写 redux-thunk 源码；</li><li>手写 Promise/A+ ；<ul><li><a href="https://juejin.cn/post/6844904116913700877">手写一个Promise/A+,完美通过官方872个测试用例</a></li><li><a href="https://juejin.cn/post/6945319439772434469">从一道让我失眠的 Promise 面试题开始，深入分析 Promise 实现细节</a></li><li><a href="https://juejin.cn/post/6844904094079926286">最简实现Promise，支持异步链式调用（20行）</a></li><li><a href="https://juejin.cn/post/7043758954496655397">手把手一行一行代码教你“手写Promise“，完美通过 Promises/A+ 官方872个测试用例</a></li></ul></li><li>排序算法，桶排序、计数排序，时间复杂度 O(n) ；</li><li>每日算法<ul><li><a href="https://labuladong.gitee.io/algo/%EF%BC%88%E5%9B%BD%E5%86%85%E9%80%9F%E5%BA%A6%E5%BF%AB%EF%BC%8C%E4%BD%93%E9%AA%8C%E5%A5%BD%EF%BC%8C%E6%8E%A8%E8%8D%90%EF%BC%89">https://labuladong.gitee.io/algo/（国内速度快，体验好，推荐）</a></li><li><a href="https://labuladong.github.io/algo/">https://labuladong.github.io/algo/</a></li><li><a href="https://mp.weixin.qq.com/s/AzQzw-pC8A-0kS0NJn2eWw">手把手刷二叉树系列完结篇</a></li><li><a href="https://mp.weixin.qq.com/s/hGrTUmM1zusPZZ0nA9aaNw">前缀树算法模板秒杀 5 道算法题</a></li><li><a href="https://mp.weixin.qq.com/s/ir1Hk06HcT8W_qz0MtyONA">2021 公众号精选文章目录</a></li></ul></li><li>看下面的文章，手写一个 <code>babel-plugin-import</code><ul><li><a href="https://juejin.cn/post/6930877602840182791">手写一个webpack，看看AST怎么用｜牛气冲天新年征文</a></li><li><a href="https://juejin.cn/post/6987036612035084296">今天，我们来实现一个基础版的webpack</a></li><li><a href="https://juejin.cn/post/6953963506693570573">前端也要懂编译：AST 从入门到上手指南</a></li><li><a href="https://juejin.cn/post/7026658230365323301">跟着源码了解Webpack编译流程</a></li><li><a href="https://juejin.cn/post/6859538537830858759">面试官：webpack原理都不会？</a></li><li><a href="https://juejin.cn/post/7026671646555504676">让 AST 操作像呼吸一样自然</a></li></ul></li><li>手把手实现一个 babel 插件<ul><li>这篇做的 demo 是一个简单的 babel-plugin-import</li><li><a href="https://juejin.cn/post/6844903746804137991">深入Babel，这一篇就够了</a></li><li>这篇做的 demo 类似 Java 中的 lambok</li><li><a href="https://juejin.cn/post/7012424646247055390">保姆级教学！这次一定学会babel插件开发！</a></li></ul></li><li>diff 算法相关<ul><li><a href="https://github.com/snabbdom/snabbdom">https://github.com/snabbdom/snabbdom</a></li><li><a href="https://juejin.cn/post/7000266544181674014">DIff算法看不懂就一起来砍我(带图)</a></li><li><a href="https://juejin.cn/post/6966215704634720287">关于Virtual DOM理解和Snabbdom源码浅析</a></li></ul></li><li>webpack 热模块替换看下源码<ul><li><a href="https://juejin.cn/post/7049608872553611301">webpack模块热更新原理</a></li><li><a href="https://juejin.cn/post/7021729340945596424">Webpack 原理系列十：HMR 原理全解析</a></li></ul></li><li>工程化方案总结下<ul><li><a href="https://zhuanlan.zhihu.com/p/403970666">2021 年 TypeScript + React 工程化指南</a></li><li><a href="https://juejin.cn/post/7017710911443959839">2021 年当我们聊前端部署时，我们在聊什么</a></li><li><a href="https://juejin.cn/post/7023242274876162084">🔥【万字】透过分析 webpack 面试题，构建 webpack5.x 知识体系</a></li><li><a href="https://github.com/vercel/next.js/blob/canary/packages/next/build/webpack-config.ts">Next.js webpack 配置</a></li></ul></li><li>字体文件的 hash 是如何生成的，<code>file-loader</code> 中如何处理的<ul><li>写一篇文章：《你不知道的 Webpack loader —— file-loader 源码探秘》</li><li><a href="https://www.cnblogs.com/shiyunfront/articles/8944940.html">webpack 源码解析:file-loader 和 url-loader</a></li><li><a href="https://github.com/webpack-contrib/file-loader/blob/master/src/index.js">file-loader - GitHub</a></li><li><a href="https://github.com/webpack/loader-utils/blob/master/lib/interpolateName.js">loader-utils - GitHub</a></li></ul></li><li><a href="https://juejin.cn/post/6992172458748936222">面向未来的前端开发模式 - 写于2021年</a></li><li><a href="https://juejin.cn/post/6990538424545443854">从零搭建Webpack5-react脚手架(附源码)</a></li><li><a href="https://github.com/JinJieTan/Peter-">手写各种源码</a></li></ul><h2>📒 推荐阅读</h2><ul><li><a href="https://zhuanlan.zhihu.com/p/403970666">2021 年 TypeScript + React 工程化指南</a></li><li><a href="https://juejin.cn/post/6996816316875161637#heading-15">学习 Webpack5 之路（优化篇）- 近 7k 字</a></li><li><a href="https://github.com/webpack/webpack-dev-middleware">https://github.com/webpack/webpack-dev-middleware</a></li><li><a href="https://segmentfault.com/a/1190000011761306">webpack-dev-middleware 插件的使用</a></li><li><a href="https://juejin.cn/post/6844904099985489927">webpack-dev-middleware 源码解读</a></li><li><a href="https://juejin.cn/post/6949040393165996040#heading-2">[<!-- -->万字总结<!-- -->]<!-- --> 一文吃透 Webpack 核心原理</a></li><li><a href="https://juejin.cn/post/7020678344219820068">跟村长老师做【Vue DevUI 开源指南】直播一个月的感受</a></li><li><a href="https://juejin.cn/post/7021167384484380709">工程化知识卡片 008: webpack HMR 实现的核心原理</a></li><li><a href="https://juejin.cn/post/7030207667457130527">基于 Lerna 实现 Monorepo 项目管理</a></li><li><a href="https://juejin.cn/post/6959115798841393160">手摸手教你用Vue3+Typescript+Rollup+Tailwinds打造插拔式的业务组件库</a></li><li><a href="https://juejin.cn/post/6869551115420041229">一文带你快速上手Rollup</a></li><li>🌛 <a href="https://juejin.cn/post/7029525775321661470">手摸手学会搭建一个 TS+Rollup 的初始开发环境</a></li><li><a href="https://juejin.cn/post/7029292539479867429">【我要做开源】Vue DevUI开源指南08：如何实现组件的按需打包📦</a></li><li><a href="https://juejin.cn/post/7029262501833359368">【我要做开源】Vue DevUI开源指南08：Monorepo改造</a></li><li><a href="https://juejin.cn/post/6974377246140301342">coding优雅指南：函数式编程</a></li><li><a href="https://juejin.cn/post/6892886272377880583">这些高阶的函数技术，你掌握了么</a></li><li>🌛 <a href="https://juejin.cn/post/7028222480326066213">使用Docker Compose、Nginx、SSH和Github Actions实现前端自动化部署测试机</a></li><li><a href="https://juejin.cn/post/6844904093434019853">如何推动前端团队的基础设施建设</a></li><li>⭐️ <a href="https://juejin.cn/post/6966491047257964575">Element UI源码中学到的技巧</a></li><li><a href="https://juejin.cn/post/7026658230365323301">跟着源码了解Webpack编译流程</a></li><li><a href="https://juejin.cn/post/6859538537830858759">面试官：webpack原理都不会？</a></li><li><a href="https://juejin.cn/post/7026671646555504676">让 AST 操作像呼吸一样自然</a></li><li><a href="https://juejin.cn/post/6920044884594425864">从零撸一个CLI命令行脚手架工具</a></li><li><a href="https://juejin.cn/post/6844904197863964685">从 Element UI 源码的构建流程来看前端 UI 库设计</a></li><li><a href="https://juejin.cn/post/6943430853972852750">那些年错过的React组件单元测试（上）</a></li><li><a href="https://juejin.cn/post/6946008649026240519">那些年错过的React组件单元测试（下）</a></li><li><a href="https://juejin.cn/post/7026274816734789663">git hooks 的库 husky 源码这么简单，你也可以实现一个！</a></li><li><a href="https://juejin.cn/post/7026210002042011655">「React18新特性」深度解读之useMutableSource</a></li><li><a href="https://juejin.cn/post/6953452438300917790">【V8源码补充篇】从一道让我失眠的 Promise 面试题开始，深入分析 Promise 实现细节</a></li><li><a href="https://juejin.cn/post/6966422095274180639">[<!-- -->探索<!-- -->]<!-- -->Webpack DevServer和HMR原理</a></li><li><a href="https://juejin.cn/post/7023242274876162084">【万字】透过分析 webpack 面试题，构建 webpack5.x 知识体系</a></li><li><a href="https://juejin.cn/post/6844903881390964744">从头开始，彻底理解服务端渲染原理(8千字汇总长文)</a></li><li><a href="https://juejin.cn/post/6982157120594509837">剖析 Webpack SplitChunksPlugin 源码: 学完你也能写一个</a></li><li><a href="https://juejin.cn/post/7025164660751990798">一点关于服务端渲染的分享</a></li><li><a href="https://juejin.cn/post/6966119324478079007">从 0 构建自己的脚手架/CLI知识体系（万字） 🛠</a></li><li><a href="https://juejin.cn/post/6984939221681176607">手写一个虚拟DOM库，彻底让你理解diff算法</a></li><li><a href="https://juejin.cn/post/6854573215969181703">10个简单的技巧让你的 vue.js 代码更优雅🍊</a></li><li><a href="https://juejin.cn/post/7026119446162997261">在 Vue 中为什么不推荐用 index 做 key</a></li><li><a href="https://www.zhihu.com/question/384048633/answer/1134746899">做了两年前端开发，平时就是拿 Vue 写写页面和组件，简历的项目经历应该怎么写得好看？</a></li><li><a href="https://juejin.cn/post/7017710911443959839">2021 年当我们聊前端部署时，我们在聊什么</a></li><li><a href="https://juejin.cn/post/7016534471734198279">分享一年以来的Electron开发经验</a></li><li><a href="https://juejin.cn/post/6844903938894872589">「前端进阶」高性能渲染十万条数据(时间分片)</a></li><li>⭐️ <a href="https://juejin.cn/post/6978654109893132318">手写系列-实现一个铂金段位的 React</a></li><li><a href="https://juejin.cn/post/6973155726302642206">手写系列-这一次，彻底搞懂 Promise</a></li><li><a href="https://juejin.cn/post/7005375860509245471">50行代码串行Promise，koa洋葱模型原来是这么实现？</a></li><li><a href="https://juejin.cn/post/6882290865763680264">玩转 node 子进程 — child_process</a></li><li><a href="https://juejin.cn/post/6844903895467032589">深入剖析：Vue核心之虚拟DOM</a></li><li>⭐️ <a href="https://juejin.cn/post/6844904055618158600">从零开始配置 react + typescript（一）：dotfiles</a></li><li><a href="https://juejin.cn/post/6937125495439900685">Webpack 案例 —— vue-loader 原理分析</a></li><li><a href="https://juejin.cn/post/7025213391618703367">TypeScript 实现斐波那契数列</a></li><li><a href="https://juejin.cn/post/6965320374451961886">用ts类型系统实现斐波那契数列</a></li></ul>]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[2月6日内容汇总]]></title>
            <link>https://your-docusaurus-test-site.com/frontend-weekly/blog/2月6日内容汇总</link>
            <guid>2月6日内容汇总</guid>
            <pubDate>Sun, 06 Feb 2022 00:00:00 GMT</pubDate>
            <description><![CDATA[📒 如何解决 CSS 兼容性问题]]></description>
            <content:encoded><![CDATA[<p>📒 如何解决 CSS 兼容性问题</p><p>对于 JS 的兼容性，我们可以使用 Babel 进行语法转换以及对 API 进行 polyfill。那么对于 CSS 的兼容性如何适配呢？可以使用 PostCSS，最完善的 CSS 工程化解决方案：</p><ul><li><code>autoprefixer</code>：根据 Can I Use 的数据给 CSS 属性添加厂商前缀</li><li><code>postcss-preset-env</code>：允许使用一些提案阶段的特性</li></ul><p>此外还提供各种插件：</p><ul><li><code>postcss-modules</code>：CSS 模块化</li><li><code>postcss-initial</code>：重置默认样式</li><li><code>sugarss</code>：支持缩进语法编写 CSS 样式</li></ul><blockquote><p><a href="https://github.com/postcss/postcss">https://github.com/postcss/postcss</a></p></blockquote><p>📒 <a href="https://www.digitalocean.com/community/tutorials/how-to-process-images-in-node-js-with-sharp#step-3-resizing-changing-image-format-and-compressing-images">How To Process Images in Node.js With Sharp</a></p><p>📒 字节跳动开源项目</p><ul><li><a href="https://github.com/bytedance/IconPark">IconPark - 支持多种主题、跨平台的图标库</a></li><li><a href="https://github.com/bytedance/xgplayer">xgplayer - HTML5 视频播放器</a></li><li><a href="https://github.com/bytedance/sonic">sonic - 基于 JIT 技术的开源全场景高性能 JSON 库</a></li><li><a href="https://github.com/bytedance/bytemd">bytemd - 字节出品的 markdown 编辑器</a></li></ul><p>📒 前端项目 babel 配置</p><p>编译一个前端项目，一般需要安装如下依赖：</p><ul><li><code>@babel/core</code>：核心库</li><li><code>babel-loader</code>：配合 Webpack 打包场景使用</li><li><code>@babel/preset-env</code>：语法转换的预设插件集，同时支持 api 兼容</li><li><code>@babel/preset-react</code>：编译 React 的 JSX 语法</li><li><code>@babel/preset-typescript</code>：可选，编译 TypeScript 语法</li></ul><p>:::tip</p><p><code>@babel/core</code> 是核心库，里面包含：</p><ul><li><code>@babel/parser</code>：一个 ast 解析器，之前叫 Babylon，基于 acorn 魔改而来，负责解析生成 ast</li><li><code>@babel/traverse</code>：负责通过访问者模式遍历并操作 ast 节点</li><li><code>@babel/generator</code>：负责根据 ast 生成代码</li></ul><p><code>babel-loader</code> 用于配合 Webpack 打包场景使用，如果想通过命令行的方式使用，则需要安装 <code>@babel/cli</code></p><p><code>@babel/preset-env</code> 的 api 兼容是通过引入 <code>core-js</code> polyfill 实现的。<code>core-js</code> 引入有多种方式，可以配置 <code>entry</code>，即在入口文件处根据根据 browserslist 配置需要适配的目标环境全量引入 polyfill，也可以配置 <code>usage</code>，根据 browserslist 配置和实际用的 api 按需引入 polyfill。<code>@babel/preset-env</code> 是通过全局污染的形式引入的，一般在前端项目中没问题，但是作为第三方库就不合适了，这时候需要使用 <code>@babel/plugin-transform-runtime</code> 通过沙箱机制引入 polyfill，这种引入方式有个缺点，无法根据 browserslist 配置动态调整引入的 polyfill。</p><p><code>@babel/preset-typescript</code> 实际上就是简单删除掉类型注解。因为 Babel 是单文件处理，不可能进行类型检查，类型检查可以交给 VSCode 插件，或者 <code>ForkTsCheckerWebpackPlugin</code> 单独起一个进程进行类型检查，这时候 tsc 的作用就是类型检查器，需要配置 <code>&quot;noEmit&quot;: true</code>。</p><p>:::</p><p>📒 写文章集合</p><ul><li>Redux 在完善下，增加 UI-binding</li><li>深入源码分析 Koa 中间件与洋葱圈模型</li><li>前端项目的 env 文件是如何被加载的</li><li>Webpack 打包的图片和字体的哈希是如何生成的 - file-loader 源码分析</li></ul>]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[1月30日内容汇总]]></title>
            <link>https://your-docusaurus-test-site.com/frontend-weekly/blog/1月30日内容汇总</link>
            <guid>1月30日内容汇总</guid>
            <pubDate>Sun, 30 Jan 2022 00:00:00 GMT</pubDate>
            <description><![CDATA[📒 推荐使用 stylus]]></description>
            <content:encoded><![CDATA[<p>📒 推荐使用 stylus</p><p>推荐使用 stylus，所有的 <code>{}</code>、<code>:</code> 以及 <code>;</code> 都是可省略的：</p><pre><code class="language-stylus">.page
  padding-bottom 2rem
  display block

.content-lock
  display none
  text-align center
  padding 2rem
  font-size 1em
</code></pre><blockquote><p>这就类似为什么建议使用 <code>yaml</code> 替代 <code>json</code>，在 <code>yaml</code> 中不需要引号，简单省事</p></blockquote><p>📒 页面性能优化技巧</p><p>分析代码执行耗时可以通过 <strong>火焰图</strong>，分析内存占用情况可以通过 <strong>堆快照</strong>。</p><p>⭐️ <a href="https://github.com/streamich/react-use">react-use - 一个 React Hooks 库</a></p><p>📒 Next.js 提供的渲染方式</p><ul><li>SSR: Server-side rendering (服务端渲染)</li><li>SSG: Static-site generation (静态站点生成)</li><li>CSR: Client-side rendering (客户端渲染)</li><li>Dynamic routing (动态路由)</li><li>ISR: Incremental Static Regeneration (增量静态再生)</li></ul><p>:::tip</p><p>CSR、SSR、SSG 的区别？</p><p>CSR 是在用户浏览器端调接口请求数据进行渲染；SSR 是在用户请求页面的时候，服务器端请求数据并进行渲染；SSG 是直接在构建阶段就进行渲染，一般用于文档网站。</p><p>:::</p><p>📒 <a href="https://zhuanlan.zhihu.com/p/461945753">Node 案发现场揭秘 —— 未定义 “window” 对象引发的 SSR 内存泄露</a></p><p>📒 <a href="https://juejin.cn/post/6844903881390964744">从头开始，彻底理解服务端渲染原理(8千字汇总长文)</a></p><p>📒 <a href="https://juejin.cn/post/7039036362653171742">【7000字】一晚上爆肝浏览器从输入到渲染完毕原理</a></p><p>📒 <a href="https://juejin.cn/post/7055101823442485255">爆肝三天，学习Scss-看这篇就够了</a></p><p>⭐️ <a href="https://juejin.cn/post/7057354419888717855">编译技术在前端的实践（二）—— Antlr 及其应用</a></p><p>⭐️ <a href="https://juejin.cn/post/6989509925844041742">编译技术在前端的实践（一）—— 编译原理基础</a></p><p>📒 如何实从零实现 husky</p><p>看下如何做 <strong>测试驱动开发</strong></p><p><a href="https://juejin.cn/post/7057345959402930183">从零实现husky</a></p><p>📒 如何让一个构造函数只能用 <code>new</code> 调用</p><p>使用 ES6 class 会检查是否通过 <code>new</code> 调用，而普通构造函数不会检查是否通过 <code>new</code> 调用，这种情况下需要手动进行判断，通常都会这样做：</p><pre><code class="language-js">function MyClass() {
  if (!(this instanceof MyClass)) {
    throw new Error(&quot;MyClass must call with new&quot;);
  }
  // ...
}
</code></pre><p>这样的话，如果不通过 <code>new</code> 调用，就会抛出异常。其实更好的方案是进行兼容处理，即不使用 <code>new</code> 调用，自动改用 <code>new</code> 调用：</p><pre><code class="language-js">function MyClass() {
  if (!(this instanceof MyClass)) {
    // 如果没有使用 `new` 调用，自动改用 `new` 调用
    // 通过 `return` 中断函数执行，并返回创建的实例
    return new MyClass();
  }
  // ...
}
</code></pre><p>📒 为什么 React Hook 底层使用链表而不是数组</p><p><a href="https://juejin.cn/post/6976903535191392270">React Hooks 核心实现</a></p><p><a href="https://www.yuque.com/liangxinchao/react/qimukg">深入浅出 React</a></p><p><a href="https://react.iamkasong.com/process/fiber-mental.html#%E4%BB%80%E4%B9%88%E6%98%AF%E4%BB%A3%E6%95%B0%E6%95%88%E5%BA%94">React 技术揭秘</a></p><p>📒 React 17 架构</p><p><a href="https://github.com/7kms/react-illustration-series/tree/v17.0.1">图解 React 原理系列</a></p><p><a href="https://react.iamkasong.com/preparation/newConstructure.html">React16架构</a></p><p>📒 数组的 <code>flatMap</code> 方法</p><p>数组的 <code>[].map()</code> 可以实现一对一的映射，映射后的数组长度与原数组相同。有时候需要过滤掉一些元素，或者实现一对多的映射，这时候只用 <code>map</code> 就无法实现了。这种情况下就可以使用 <code>flatMap</code>：</p><pre><code class="language-js">// 需要过滤掉 0，并且使其余各元素的值翻倍
const numbers = [0, 3, 6];

// 常规方法是 map 和 filter 搭配
const doubled = numbers
  .filter(n =&gt; n !== 0)
  .map(n =&gt; n * 2)

// 使用 flatMap 实现
const doubled = numbers.flatMap(number =&gt; {
  return number === 0 ? [] : [2 * number];
})
</code></pre><p>此外还可以实现一对多的映射：</p><pre><code class="language-js">const numbers = [1, 4];
const trippled = numbers.flatMap(number =&gt; {
  return [number, 2 * number, 3 * number];
})
console.log(trippled); // [1, 2, 3, 4, 8, 12]
</code></pre><p>:::tip</p><p><code>flatMap</code> 实际上是先 <code>map</code> 再 <code>flat</code>，理解了这一点就能掌握了</p><p>:::</p><p>📒 <a href="https://blog.appsignal.com/2022/01/19/how-to-set-up-a-nodejs-project-with-typescript.html">如何用 TypeScript 配置一个 Node 项目</a></p><p>📒 <a href="https://remix.run/blog/remix-vs-next">Remix vs Next.js</a></p><p>📒 <a href="https://blog.openreplay.com/3-react-component-design-patterns-you-should-know-about/">你应该知道的三个 React 组件设计模式</a></p><p>📒 <a href="https://juejin.cn/post/7055202073511460895">V8 Promise源码全面解读，其实你对Promise一无所知</a></p><p>⭐️ <a href="https://juejin.cn/post/7036162494573838367">60+ 实用 React 工具库，助力你高效开发！</a></p><p>⭐️ <a href="https://mp.weixin.qq.com/s/1BX5xK0wpUDBSininJbYHw">写好 JSX 条件语句的几个建议</a></p><p>📒 <a href="https://www.youtube.com/watch?v=M3BM9TB-8yA">Node.js 十大设计缺陷 - Ryan Dahl - JSConf EU</a></p><p>📒 <a href="https://juejin.cn/post/7056612950412361741">为什么说 WebAssembly 是 Web 的未来？</a></p><p>📒 <a href="https://juejin.cn/post/7047329886502912030">浅析TypeScript Compiler 原理</a></p><p>📒 <a href="https://juejin.cn/post/7056018952098414605">TypeScript 4.6 beta 发布：递归类型检查增强、参数的控制流分析支持、索引访问的类型推导</a></p>]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[1月23日内容汇总]]></title>
            <link>https://your-docusaurus-test-site.com/frontend-weekly/blog/1月23日内容汇总</link>
            <guid>1月23日内容汇总</guid>
            <pubDate>Sun, 23 Jan 2022 00:00:00 GMT</pubDate>
            <description><![CDATA[📒 Golang 如何根据指针访问对应的值]]></description>
            <content:encoded><![CDATA[<p>📒 Golang 如何根据指针访问对应的值</p><p>原始类型需要手动使用 <code>*</code> 操作符，复杂对象会自动解除指针引用：</p><pre><code class="language-go">num := &amp;42
fmt.Println(num) // 打印的是内存地址
fmt.Println(*num) // 42

ms := &amp;myStruct{foo: 42}
(*ms).foo = 17
fmt.Println((*ms).foo) // 17
// 对于复杂对象，直接操作就行
ms.foo = 17
fmt.Println(ms.foo) // 17
</code></pre><p>📒 Golang 创建对象指针的三种方式</p><p>Golang 中所有的赋值操作都是 copy，例如原始类型、<code>array</code>、<code>struct</code>，有两种例外：<code>map</code> 和 <code>slice</code>，它们具有内部指针，在赋值的时候传递指针类型。</p><pre><code class="language-go">// 第一种：对已有的值类型使用 `&amp;` 操作符
ms := myStruct{foo: 42}
p := &amp;ms

// 第二种：在初始化的时候使用 `&amp;` 操作符
p := &amp;myStruct{foo: 42}

// 第三种：使用 `new` 关键字，这种方法不能在初始化的时候进行赋值
var ms *myStruct = new(myStruct)
</code></pre><p>📒 如何渲染虚拟 DOM</p><p>所谓虚拟 DOM 其实就是一棵多叉树，可以使用下面的结构表示：</p><pre><code class="language-ts">class VDOM {
  type: ElementTagName;
  props: ElementProps;
  children: VDOM[];
}
</code></pre><p>渲染虚拟 DOM，很明显要用递归，对不同的类型做不同的处理：</p><ul><li>如果是文本类型，就要用 <code>document.createTextNode</code> 创建文本节点；</li><li>如果是元素类型，就要用 <code>document.createElement</code> 创建元素节点，元素节点还有属性要处理，并且要递归渲染子节点；</li></ul><p>实现 <code>render</code> 函数如下：</p><pre><code class="language-js">const render = (vdom, parent = null) =&gt; {
  const mount = (el) =&gt; {
    if (!parent) return el;
    // 如有父节点则挂载到父节点，组装为 DOM 树
    return parent.appendChild(el);
  }
  if (isTextVdom(vdom)) {
    // 创建文本节点
    return mount(document.createTextNode(vdom));
  } else if (isElementVdom(vdom)) {
    // 创建元素节点
    const dom = mount(document.createElement(vdom.type));
    // 递归渲染子节点，这里使用深度优先遍历
    for (const child of vdom.children) {
      render(child, dom);
    }
    // 给元素添加属性
    for (const prop in vdom.props) {
      setAttribute(dom, prop, vdom.props[prop]);
    }
    return dom;
  }
};
</code></pre><p>如何判断文本节点：</p><pre><code class="language-js">function isTextVdom(vdom) {
  return typeof vdom == &#x27;string&#x27; || typeof vdom == &#x27;number&#x27;;
}
</code></pre><p>如何判断元素节点：</p><pre><code class="language-js">function isElementVdom(vdom) {
  return typeof vdom == &#x27;object&#x27; &amp;&amp; typeof vdom.type == &#x27;string&#x27;;
}
</code></pre><p>如何处理样式、事件、属性：</p><pre><code class="language-js">const setAttribute = (dom, key, value) =&gt; {
  if (typeof value == &#x27;function&#x27; &amp;&amp; key.startsWith(&#x27;on&#x27;)) {
    // 事件处理，使用 `addEventListener` 设置
    const eventType = key.slice(2).toLowerCase();
    dom.addEventListener(eventType, value);
  } else if (key == &#x27;style&#x27; &amp;&amp; typeof value == &#x27;object&#x27;) {
    // 样式处理，合并样式
    Object.assign(dom.style, value);
  } else if (typeof value != &#x27;object&#x27; &amp;&amp; typeof value != &#x27;function&#x27;) {
    // 属性处理，使用 `setAttribute` 设置
    dom.setAttribute(key, value);
  }
}
</code></pre><p>📒 <a href="https://juejin.cn/post/7054034318594850823">能用js实现的最终用js实现，Shell脚本也不例外</a></p><p>📒 <a href="https://github.com/luciopaiva/heapify">heapify：最快的 JavaScript 优先级队列库</a></p><p>📒 <a href="https://github.com/mailru/easyjson">easyjson：Golang 中的序列化库，比 <code>encoding/json</code> 快 4-5 倍</a></p><p>📒 <a href="https://github.com/fastify/fast-json-stringify">fast-json-stringify：比 <code>JSON.stringify</code> 快两倍</a></p><p>📒 <a href="https://juejin.cn/post/7048970987500470279">六千字详解！vue3 响应式是如何实现的？</a></p><p>📒 Nodejs 如何将图片转为 base64</p><p>使用 Buffer 对象：</p><pre><code class="language-js">import fs from &quot;node:fs&quot;;
import path from &quot;node:path&quot;;

const raw = fs.readFileSync(path.join(__dirname, &#x27;./2333.png&#x27;), &#x27;binary&#x27;);
const buf = Buffer.from(raw, &#x27;binary&#x27;);
const string = buf.toString(&#x27;base64&#x27;);
</code></pre><p>同理可以将 base64 转回图片：</p><pre><code class="language-js">const raw =  Buffer.from(string, &#x27;base64&#x27;).toString(&#x27;binary&#x27;);
</code></pre><p>📒 Nodejs 如何实现图片处理</p><p>推荐使用 <code>sharp</code> 这个库，可以实现图片压缩，转 JPEG、PNG、WebP 等格式：</p><blockquote><p><a href="https://github.com/lovell/sharp">https://github.com/lovell/sharp</a></p></blockquote><p>📒 如何打印 26 个字母的字符串</p><p>一行代码搞定：</p><pre><code class="language-js">String.fromCharCode(...Array.from({ length: 26 }, (_, index) =&gt; 97 + index));
// &#x27;abcdefghijklmnopqrstuvwxyz&#x27;
</code></pre><p>📒 如何用 Map 实现 Set</p><p>关于 Map 和 Set 是两个抽象数据结构，Map 存储一个键值对集合，其中键不重复，Set 存储一个不重复的元素集合。本质上 Set 可以视为一种特殊的 Map，Set 其实就是 Map 中的键：</p><pre><code class="language-ts">class NewSet&lt;T extends unknown&gt; {
  private collection: Map&lt;T, undefined&gt;;
  
  constructor(iterable: T[] = []) {
    this.collection = new Map(
      iterable.map(it =&gt; [it, undefined])
    );
  }
}
</code></pre><p>📒 方法重载与参数默认值</p><p>为了支持可变参数，在 Java 中通过 <strong>方法重载</strong> 实现，通过定义多个方法签名，根据实际调用传递的参数去匹配签名。在 TypeScript 中也提供了方法重载特性，但在开发中很少用到，一般都通过 <strong>参数默认值</strong> 实现可变参数：</p><pre><code class="language-ts">type NewSet&lt;T&gt; = (iterable: T[] = []) =&gt; void
</code></pre><blockquote><p>注意使用参数默认值之后，TS 会自动将这个参数推导为可变参数，例如上面这个会推导为 <code>NewSet&lt;T&gt;(iterable?: T[]): void</code></p></blockquote><p>📒 项目常用工具库</p><ul><li><code>dayjs</code>：与 <code>moment</code> 的 API 设计保持一样，但体积仅有 2KB；</li><li><code>qs</code>：解析 URL query 参数的库；</li><li><code>js-cookie</code>：简单、轻量的处理 cookie 的库；</li><li><code>flv.js</code>：bilibili 开源的 HTML5 flash 播放器，使浏览器在不借助 flash 插件的情况下可以播放 flv；</li><li><code>vConsole</code>：一个轻量、可拓展、针对手机网页的前端开发者调试面板；</li><li><code>animate.css</code>：一个跨浏览器的 css3 动画库，内置了很多典型的 css3 动画，兼容性好，使用方便；</li><li><code>lodash</code>：一个一致性、模块化、高性能的 JavaScript 实用工具库；</li></ul><p>⭐️ <a href="https://github.com/ngneat/elf">elf: 使用 RxJs 的响应式状态管理</a></p><p>📒 如何防止 CSS 样式污染</p><ul><li>使用命名约定</li><li>CSS Modules</li><li>CSS in JS</li></ul><p>其中命名约定最流行的方式是 BEM 101。它代表了 <code>Block</code>、<code>Element</code>、<code>Modifier</code> 方法。</p><pre><code class="language-css">[block]__[element]--[modifier]
/* Example */
.menu__link--blue {
  ...
}
</code></pre><p>📒 <a href="https://juejin.cn/post/7040849488998563848">现代配置指南——YAML 比 JSON 高级在哪？</a></p><p>📒 <a href="https://juejin.cn/post/7029512357428592648">前端架构师神技，三招统一团队代码风格</a></p><p>📒 <a href="https://juejin.cn/post/7024043015794589727">前端架构师的 git 功力，你有几成火候？</a></p>]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[1月16日内容汇总]]></title>
            <link>https://your-docusaurus-test-site.com/frontend-weekly/blog/1月16日内容汇总</link>
            <guid>1月16日内容汇总</guid>
            <pubDate>Sun, 16 Jan 2022 00:00:00 GMT</pubDate>
            <description><![CDATA[📒 实现一个 WebAssembily 版本的 Python 解释器]]></description>
            <content:encoded><![CDATA[<p>📒 实现一个 WebAssembily 版本的 Python 解释器</p><ul><li>wasm 可以把代码编译出来，但是能否执行</li><li>如果 Python 代码涉及系统调用，例如代码中经常需要进行文件 IO，这种情况下 wasm 能否实现</li></ul><blockquote><p><a href="https://github.com/pyodide/pyodide">https://github.com/pyodide/pyodide</a></p></blockquote><p>📒 Webpack5 配置了 <code>devServer.hot = true</code> 是否会自动配置 <code>HotModuleReplacementPlugin</code></p><p>📒 看下 axios 源码，响应拦截中第一个回调 <code>reject</code> 能否进入第二个回调</p><p>📒 webpack-dev-server 如何配置代理</p><details><summary>查看详情</summary><p>在 CRA 搭建的项目中，我们知道可以在 <code>src/setupProxy.js</code> 文件中写入代理配置：</p><pre><code class="language-js">const proxy = require(&#x27;http-proxy-middleware&#x27;);

module.exports = function(app) {
  app.use(
    proxy(
      &#x27;/course&#x27;,
      {
        target: &#x27;https://ke.study.163.com&#x27;,
        changeOrigin: true,
      },
    ),
  )
}
</code></pre><p>那么手动搭建的项目该如何配置代理呢？我们看一下 CRA 源码：</p><pre><code class="language-js">// react-scripts/config/paths.js:87

module.exports = {
  // ...
  proxySetup: resolveApp(&#x27;src/setupProxy.js&#x27;),
  // ...
}
</code></pre><p>然后去找哪里用到了 <code>proxySetup</code> ：</p><pre><code class="language-js">// react-scripts/config/webpackDevServer.config.js:112

onBeforeSetupMiddleware(devServer) {
  // Keep `evalSourceMapMiddleware`
  // middlewares before `redirectServedPath` otherwise will not have any effect
  // This lets us fetch source contents from webpack for the error overlay
  devServer.app.use(evalSourceMapMiddleware(devServer));

  if (fs.existsSync(paths.proxySetup)) {
    // This registers user provided middleware for proxy reasons
    require(paths.proxySetup)(devServer.app);
  }
},
</code></pre><p>看了下上面的配置，说明应该是这么用的：</p><pre><code class="language-js">const compiler = webpack(config);
const devServer = new WebpackDevServer(options, compiler);

devServer.app.use(
  proxy(
    &#x27;/course&#x27;,
    {
      target: &#x27;https://ke.study.163.com&#x27;,
      changeOrigin: true,
    },
  ),
)
</code></pre></details><p>📒 <a href="https://juejin.cn/post/7051535411042058271">不优雅的 React Hooks</a></p><p>📒 为什么可以用函数模拟一个模块</p><p>在一个模块中，有一些属性和方法是私有的，另外一些是对外暴露的：</p><pre><code class="language-js">// main.js
let foo = 1;
let bar = 2;

export const getFoo = () =&gt; foo;
export const getBar = () =&gt; bar;
const defaultExport = () =&gt; foo + bar;
export default defaultExport;

// index.js
import main, { getFoo, getBar } from &quot;./main&quot;;
</code></pre><p>这种行为就可以通过函数模拟出来，其中私有变量、方法以闭包的形式实现，这样只有模块内部才能访问：</p><pre><code class="language-js">const main = (function() {
  let foo = 1;
  let bar = 2;
  const getFoo = () =&gt; foo;
  const getBar = () =&gt; bar;
  const defaultExport = () =&gt; foo + bar;

  return {
    getFoo,
    getBar,
    default: defaultExport
  }
})();
</code></pre><p>:::tip</p><p>可以看到给默认导出加了一个 <code>deafult</code> 属性。</p><p>:::</p><p>另外推荐看看 <code>browserify</code> 这个库，如何在浏览器端实现 CommonJS 模块机制：</p><blockquote><p><a href="https://browserify.org/">https://browserify.org/</a></p></blockquote><p>📒 Webpack 中 loader 处理流程</p><p>有点像责任链模式，上一个函数的返回值会作为参数传入下一个函数。需要注意使用 <code>call</code> 方法让每个 loader 内部可以获取到 loaderAPI：</p><pre><code class="language-js">import { readFileSync } from &#x27;node:fs&#x27;;

const loaders = [];
const raw = readFileSync(&#x27;xxx&#x27;);

const loaderAPI = {
  emitFile: () =&gt; {},
}

const parsed = loaders.reduce(
  (accu, cur) =&gt; cur.call(loaderAPI, accu),
  raw
);
</code></pre><p>📒 字体文件的 hash 是如何生成的，<code>file-loader</code> 中如何处理的</p><p>写一篇文章：《你不知道的 Webpack loader —— file-loader 源码探秘》</p><p><a href="https://www.cnblogs.com/shiyunfront/articles/8944940.html">webpack 源码解析:file-loader 和 url-loader</a></p><p><a href="https://github.com/webpack-contrib/file-loader/blob/master/src/index.js">file-loader - GitHub</a></p><p><a href="https://github.com/webpack/loader-utils/blob/master/lib/interpolateName.js">loader-utils - GitHub</a></p><p>📒 Golang 编译为 WebAssembly</p><p>在 Golang 中可以使用 <code>syscall/js</code> 这个库与 JS 环境进行交互，可以调用 JS 的 API，以及传递 JSON 数据：</p><pre><code class="language-go">package main
 
import (
    &quot;encoding/json&quot;
    &quot;fmt&quot;
    &quot;syscall/js&quot;
)
 
type Person struct {
    Name string `json:&quot;name&quot;`
    Age  int    `json:&quot;age&quot;`
}

func main() {
  // Work around for passing structs to JS
  frank := &amp;Person{Name: &quot;Frank&quot;, Age: 28}
  p, err := json.Marshal(frank)
  if err != nil {
      fmt.Println(err)
      return
  }
  obj := js.Global().Get(&quot;JSON&quot;).Call(&quot;parse&quot;, string(p))
  js.Global().Set(&quot;aObject&quot;, obj)
}
</code></pre><p><a href="https://www.sitepen.com/blog/compiling-go-to-webassembly">Compiling Go to WebAssembly</a></p><p>📒 Golang 中的指针</p><p>对于原始类型来说，赋值就等于 copy，相当于在内存中创建一个一模一样的值，具有不同的内存地址：</p><pre><code class="language-go" metastring="{3}">func main() {
  a := 42
  b := a
  fmt.Println(a, b) // 42 42
  a = 27
  fmt.Println(a, b) // 27 42
}
</code></pre><p>可以通过 <code>&amp;</code> 操作符取到内存地址：</p><pre><code class="language-go" metastring="{3}">func main() {
  var a int = 42
  var b *int = &amp;a
  fmt.Println(a, b) // 42 0×1040a124
}
</code></pre><p>还可以通过 <code>*</code> 操作符根据内存地址访问对应的值：</p><pre><code class="language-go" metastring="{4}">func main() {
  var a int = 42
  var b *int = &amp;a
  fmt.Println(a, *b) // 42 42
}
</code></pre><p>由于 <code>b</code> 实际持有的是 <code>a</code> 的指针引用，因此修改 <code>a</code> 会导致 <code>b</code> 指向的值发生变化：</p><pre><code class="language-go" metastring="{5,7}">func main() {
  var a int = 42
  var b *int = &amp;a
  fmt.Println(a, *b) // 42 42
  a = 27
  fmt.Println(a, *b) // 27 27
  *b = 14
  fmt.Println(a, *b) // 14 14
}
</code></pre><p>📒 Golang 中的 <code>struct</code></p><p>注意 <code>struct</code> 与 <code>slice</code>、<code>map</code> 不同，下面这个操作实际上是完整 copy 了一个对象，内存开销较大：</p><pre><code class="language-go" metastring="{15}">package main

import (
  &quot;fmt&quot;
)

type Doctor struct {
  name string
}

func main() {
  aDoctor := Doctor{
    name: &quot;John Pertwee&quot;
  }
  anotherDoctor := aDoctor
  anotherDoctor.name = &quot;Tom Baker&quot;
  fmt.Println(aDoctor) // {John Pertwee}
  fmt.Println(anotherDoctor) // {Tom Baker}
}
</code></pre><p>可以使用 <code>&amp;</code> 操作符拿到对象的指针进行赋值，这时候两边就是联动的：</p><pre><code class="language-go" metastring="{5}">func main() {
  aDoctor := Doctor{
    name: &quot;John Pertwee&quot;
  }
  anotherDoctor := &amp;aDoctor
  anotherDoctor.name = &quot;Tom Baker&quot;
  fmt.Println(aDoctor) // {Tom Baker}
  fmt.Println(anotherDoctor) // &amp;{Tom Baker}
}
</code></pre><p>注意 <code>array</code> 进行赋值也会 copy：</p><pre><code class="language-go" metastring="{2}">func main() {
  a := [3]int{1, 2, 3}
  b := a
  fmt.Println(a, b) // [1, 2, 3] [1, 2, 3]
  a[1] = 42
  fmt.Println(a, b) // [1, 42, 3] [1, 2, 3]
}
</code></pre><p>但如果将 <code>array</code> 改为 <code>slice</code>，赋值传递的就是指针：</p><pre><code class="language-go" metastring="{2}">func main() {
  a := []int{1, 2, 3}
  b := a
  fmt.Println(a, b) // [1, 2, 3] [1, 2, 3]
  a[1] = 42
  fmt.Println(a, b) // [1, 2, 3] [1, 2, 3]
}
</code></pre><p>📒 <a href="https://juejin.cn/post/7051929587852247077">年终盘点：2022基于Monorepo的首个大趋势-TurboRepo</a></p><p>⭐️ <a href="https://juejin.cn/post/7034419410706104356">2022年如何成为一名优秀的大前端Leader？</a></p><p>📒 GitHub 定时任务</p><p>下面的代码中，<code>on</code> 字段指定了两种触发条件，一个是代码 <code>push</code> 进仓库，另一种是定时任务，每天在国际标准时间21点（北京时间早上5点）运行。</p><pre><code class="language-yaml">on:
  push:
  schedule:
    - cron: &#x27;0 21 * * *&#x27;
</code></pre><p>定时任务配置参考：</p><blockquote><p><a href="https://github.com/lxchuan12/juejin-actions">https://github.com/lxchuan12/juejin-actions</a></p></blockquote><p>另外推荐一个项目，可以使用 <code>curl wttr.in</code> 命令获取天气预报：</p><blockquote><p><a href="https://github.com/chubin/wttr.in">https://github.com/chubin/wttr.in</a></p></blockquote><p>📒 如何开发一个 CLI 工具</p><p>参考下尤大的项目：</p><pre><code class="language-js">const templateDir = path.join(__dirname, `template-${template}`)

const write = (file, content) =&gt; {
  const targetPath = renameFiles[file]
    ? path.join(root, renameFiles[file])
    : path.join(root, file)
  if (content) {
    fs.writeFileSync(targetPath, content)
  } else {
    copy(path.join(templateDir, file), targetPath)
  }
}

const files = fs.readdirSync(templateDir)
for (const file of files.filter((f) =&gt; f !== &#x27;package.json&#x27;)) {
  write(file)
}
</code></pre><p>注意这里有两个文件要处理下，一个是给 <code>package.json</code> 修改包名：</p><pre><code class="language-js">const pkg = require(path.join(templateDir, `package.json`))

pkg.name = packageName || targetDir

write(&#x27;package.json&#x27;, JSON.stringify(pkg, null, 2))
</code></pre><p>还有是 <code>.gitignore</code> 修改文件名：</p><pre><code class="language-js">const renameFiles = {
  _gitignore: &#x27;.gitignore&#x27;
}
</code></pre><blockquote><p><a href="https://github.com/vitejs/vite/blob/main/packages/create-vite/index.js">https://github.com/vitejs/vite/blob/main/packages/create-vite/index.js</a></p></blockquote><p>📒 命令行工具开发技术栈</p><ul><li><code>chalk/kolorist</code></li><li><code>inquirer/prompts</code></li><li><code>ora</code></li><li><code>semver</code></li><li><code>pkg-install</code></li><li><code>ncp</code></li><li><code>commander/yargs</code></li><li><code>execa</code>（个人觉得 Node 原生 <code>child_process</code> 的 <code>exec</code> 就够用了）</li><li><code>minimist</code></li></ul><p>:::tip</p><p>网上一些文章也都实现了递归拷贝文件，但是是否考虑到了跨平台，可以看下 <code>ncp</code> 的实现</p><p><a href="https://github.com/AvianFlu/ncp">https://github.com/AvianFlu/ncp</a></p><p>Node.js 原生的 <code>child_process.exec</code> 也可以执行命令，看下 <code>execa</code> 是如何支持 Promise 的</p><p><a href="https://github.com/sindresorhus/execa">https://github.com/sindresorhus/execa</a></p><p>:::</p><p>现在开发已经不需要自己组装 pick 了，<code>common-bin</code>、<code>oclif</code> 这两个，约定式路由。</p><p>另外脚手架工具，可以看看 <code>plop</code>和 <code>yeoman</code>，一个是基于 <code>action</code> 和 <code>inquirer</code> 的生态，一个是内核加自定义模板项目。</p><p>其实最简单的脚手架，不是通过cli界面选择模板，然后到 github 上去下载对应的模板文件，而是 <code>start-kit</code> 。</p><blockquote><p><a href="https://github.com/digipolisantwerp/starter-kit-ui_app_nodejs">https://github.com/digipolisantwerp/starter-kit-ui_app_nodejs</a></p></blockquote><p>📒 <a href="https://juejin.cn/post/7051355444341637128">「前端基建」探索不同项目场景下Babel最佳实践方案</a></p><p>📒 <a href="https://juejin.cn/post/7051236803344334862">说不清rollup能输出哪6种格式😥差点被鄙视</a></p><p>📒 <a href="https://juejin.cn/post/7035448197883363359">【手把手】学会VS Code&quot;任务&quot;神技，成为项目组最靓的崽！</a></p>]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[1月9日内容汇总]]></title>
            <link>https://your-docusaurus-test-site.com/frontend-weekly/blog/1月9日内容汇总</link>
            <guid>1月9日内容汇总</guid>
            <pubDate>Sun, 09 Jan 2022 00:00:00 GMT</pubDate>
            <description><![CDATA[📒 Golang 模拟 JS 的 Promise]]></description>
        </item>
        <item>
            <title><![CDATA[1月2日内容汇总]]></title>
            <link>https://your-docusaurus-test-site.com/frontend-weekly/blog/1月2日内容汇总</link>
            <guid>1月2日内容汇总</guid>
            <pubDate>Sun, 02 Jan 2022 00:00:00 GMT</pubDate>
            <description><![CDATA[📒 clsx：classnames 的替代方案]]></description>
        </item>
        <item>
            <title><![CDATA[12月26日内容汇总]]></title>
            <link>https://your-docusaurus-test-site.com/frontend-weekly/blog/12月26日内容汇总</link>
            <guid>12月26日内容汇总</guid>
            <pubDate>Sun, 26 Dec 2021 00:00:00 GMT</pubDate>
            <description><![CDATA[📒 腾讯技术工程相关文章]]></description>
            <content:encoded><![CDATA[<p>📒 腾讯技术工程相关文章</p><ul><li><a href="https://zhuanlan.zhihu.com/p/334617737">14W 行代码量的前端页面长什么样</a></li><li><a href="https://zhuanlan.zhihu.com/p/90836859">万字长文轻松彻底入门 Flutter，秒变大前端</a></li><li><a href="https://zhuanlan.zhihu.com/p/444802648">Git 分支操作&amp;存储原理浅谈</a></li><li><a href="https://zhuanlan.zhihu.com/p/405387352">QUIC 协议详解</a></li></ul><p>⭐️ <a href="https://zhuanlan.zhihu.com/p/340814811">收藏 | 腾讯技术 2020 年精华文章合集</a></p><p>🐛 生产环境如何 debug</p><ul><li>定位错误是前端还是后端接口返回的<ul><li>前端代码全局搜索关键字（vscode 或者 chorme devtools 中搜索）</li><li>翻阅 network 面板中的请求，使用 <code>⌘ + F</code> 打开 network search 面板进行搜索</li></ul></li><li>如何调试混淆压缩后的 JS<ul><li>使用 source 面板中的 pretty-print 选项</li><li>这样还是存在问题，例如很多变量名、方法名都被混淆压缩了，然后 babel 会将 ES2015+ 语法进行语法转换，代码可读性降低</li></ul></li><li>如何在生产环境中使用 sourceMap 调试<ul><li>打开混淆压缩的代码，右键选择 Add source map</li><li>这里需要添加一个 source map URL，可以将本地项目添加到 source 面板中的 Filesystem 中，或者启用静态资源服务</li><li>添加之后就可以直接搜索项目中的源文件了</li></ul></li><li>如何在 chrome 中修改代码并调试<ul><li>chrome devtools 提供了 local overrides 能力，指定修改后的文件的本地保存目录，当修改完代码保存的时候，就会将修改后的文件保存到你指定的目录目录下，当再次加载页面的时候，对应的文件不再读取网络上的文件，而是读取存储在本地修改过的文件</li><li>打开 sources 下的 overrides 面板，点击 select folder overrides 选择修改后的文件件存储地址，我们就可以打开文件修改，修改完成后保存，重新刷新页面后，修改后的代码就被执行到了</li></ul></li></ul><blockquote><p><a href="https://juejin.cn/post/7044678301926817806">前端工程师生产环境 debugger 技巧</a></p></blockquote><p>📒 如何在 React 中优雅使用 ECharts</p><p>初始化 ECharts 的时候不要使用 id，否则无法渲染多个组件实例：</p><pre><code class="language-jsx" metastring="{5,8,15}">import * as React from &quot;react&quot;;
import * as echarts from &quot;echarts&quot;;

const LineChart = (props) =&gt; {
  const chartRef = React.useRef();

  React.useEffect(() =&gt; {
    const chart = echarts.init(chartRef.current);
    const option = {
      // ...
    }
    chart.setOptions(option);
  }, [props])
  
  return &lt;div ref={chartRef} className=&quot;chart&quot;&gt;&lt;/div&gt;
}

export default React.memo(LineChart);
</code></pre><p>如何让 ECharts 实现自适应，可以在窗口尺寸变化的时候，调用 chart 实例上的 <code>resize</code> 方法：</p><pre><code class="language-jsx" metastring="{8-10,13,17}">React.useEffect(() =&gt; {
  const chart = echarts.init(chartRef.current);
  const option = {
    // ...
  }
  chart.setOptions(option);

  const handleResize = () =&gt; {
    chart.resize();
  }

  // 绑定 resize 事件监听器
  window.addEventListener(&quot;resize&quot;, handleResize);

  return () =&gt; {
    // 组件更新或者卸载时移除监听
    window.removeEventListener(&quot;resize&quot;, handleResize);
  }
}, [props])
</code></pre><blockquote><p>推荐使用 <code>addEventListener</code> 绑定事件，可以多次绑定，但是要注意及时 remove，不然会导致内存泄漏</p></blockquote><p>📒 看火焰图分析调用栈的时候，看到一个 <code>asyncGeneratorStep</code> 的函数，一直没搞清楚这个在哪里用到了</p><p><img src="./POPO20211223-201441.png" alt="image"/></p><p>事后才想到这是 babel 语法转换引入的 helper 函数</p><p><img src="./POPO20211223-113701.png" alt="image"/></p><p>📒 使用 webpack-chain 对 vue-cli 默认配置进行修改</p><blockquote><p><a href="https://github.com/Yatoo2018/webpack-chain/tree/zh-cmn-Hans">https://github.com/Yatoo2018/webpack-chain/tree/zh-cmn-Hans</a></p></blockquote><p>📒 如何对 webpack 打包产物进行分析</p><p>经常需要分析打包产物的体积，看哪个包体积过大，做针对性优化。可以使用 Webpack Bundle Analyzer：</p><pre><code class="language-bash">$ yarn add webpack-bundle-analyzer -D
</code></pre><p>在 <code>webpack.config.js</code> 中添加如下配置：</p><pre><code class="language-js">const { BundleAnalyzerPlugin } = require(&#x27;webpack-bundle-analyzer&#x27;);

module.exports = {
  plugins: [
    new BundleAnalyzerPlugin()
  ]
}
</code></pre><p>然后执行打包构建命令：</p><pre><code class="language-bash">$ yarn build --report
</code></pre><blockquote><p><a href="https://github.com/webpack-contrib/webpack-bundle-analyzer">https://github.com/webpack-contrib/webpack-bundle-analyzer</a></p></blockquote><p>📒 create-react-app 发布 5.0 版本</p><p>本次的 5.0 版本优化了快速刷新(Fast Refresh)，支持了 Tailwind，并更新了不少内部依赖库，如 Webpack 5、Jest 27 和 EsLint 8 等。</p><blockquote><p><a href="https://github.com/facebook/create-react-app/releases/tag/v5.0.0">https://github.com/facebook/create-react-app/releases/tag/v5.0.0</a></p></blockquote><p>📒 处理你应用中的内存泄漏</p><p>作者 Stoyan 提到：“任何大小合理的应用中，都会存在一定程度的内存泄漏”。因此知道如何处理泄漏是一件很有用的事。在本文中，作者举了一个 React 中的例子，不过它的基本理念却可以运用在任何地方。</p><blockquote><p><a href="https://calendar.perfplanet.com/2021/plugging-memory-leaks-in-your-app/">https://calendar.perfplanet.com/2021/plugging-memory-leaks-in-your-app/</a></p></blockquote><p>📒 kalidokit：人体动作表情解读同步</p><p>效果还是和牛逼的，真人测试。</p><blockquote><p><a href="https://github.com/yeemachine/kalidokit">https://github.com/yeemachine/kalidokit</a></p></blockquote><p>📒 xterm：把命令行搬到浏览器</p><blockquote><p><a href="https://xtermjs.org/">https://xtermjs.org/</a></p></blockquote><p>📒 microdiff：轻量快速的对比库</p><blockquote><p><a href="https://github.com/AsyncBanana/microdiff">https://github.com/AsyncBanana/microdiff</a></p></blockquote>]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[12月19日内容汇总]]></title>
            <link>https://your-docusaurus-test-site.com/frontend-weekly/blog/12月19日内容汇总</link>
            <guid>12月19日内容汇总</guid>
            <pubDate>Sun, 19 Dec 2021 00:00:00 GMT</pubDate>
            <description><![CDATA[⭐️ Webpack 分包最佳实践]]></description>
            <content:encoded><![CDATA[<p>⭐️ Webpack 分包最佳实践</p><p>SplitChunksPlugin 进行分包的三要素:</p><ol><li><code>minChunks</code>: 一个模块是否最少被 minChunks 个 chunk 所引用</li><li><code>maxInitialRequests/maxAsyncRequests</code>: 最多只能有 maxInitialRequests/maxAsyncRequests 个 chunk 需要同时加载 (如一个 Chunk 依赖 VendorChunk 才可正常工作，此时同时加载 chunk 数为 2)</li><li><code>minSize/maxSize</code>: chunk 的体积必须介于 (minSize, maxSize) 之间</li></ol><p>哪些应该单独分包：</p><ol><li>Webpack 运行时</li><li>React Framework 运行时，包括 React/React-DOM 及它们所有的依赖</li><li>大型库，体积特别大的库</li><li>公共库，至少被 4 个 Chunk 所引用的公共模块</li></ol><p>:::tip</p><p>Webpack 配置最佳实践，除了 Vue-cli 和 CRA 源码，还可以参考 <code>next.js</code> 源码：</p><p><a href="https://github.com/vercel/next.js/blob/canary/packages/next/build/webpack-config.ts">https://github.com/vercel/next.js/blob/canary/packages/next/build/webpack-config.ts</a></p><p>:::</p><p><a href="https://mp.weixin.qq.com/s/LrASIdA19iwIwng29G5HpA">Webpack 性能系列四：分包优化</a></p><p>📒 <a href="https://mp.weixin.qq.com/s/AxwT588VKRxnlkBlXICMpQ">【内部分享】看向未来 - 近期 TC39 提案汇总</a></p><p>📒 如何移除代码中的 <code>console</code></p><ol><li><p>使用 <code>uglifyjs-webpack-plugin</code> 或 <code>terser-webpack-plugin</code> 中的 <code>drop_console</code> 配置；</p></li><li><p>使用 Babel 插件 <code>babel-plugin-transform-remove-console</code>；</p></li><li><p>简单粗暴删除，直接重写 <code>console.log</code> 方法；</p><pre><code class="language-js">console.log = function() {};
</code></pre></li><li><p>手写 webpack loader 删除；</p><pre><code class="language-js">// clearConsole.js
const reg = /(console.log\()(.*)(\))/g;
module.exports = function(source) {
    source = source.replace(reg, &quot;&quot;)
    return source;
}
</code></pre><blockquote><p>基于正则匹配还是有一些问题，例如 <code>const { log } = console</code> 或者 <code>const log = console.log.bind(console)</code> 这种就匹配不到</p></blockquote></li></ol><p>📒 WebRTC 录屏技术</p><p>WebRTC 是一套基于音视轨的实时数据流传播的技术方案。通过浏览器原生 API <code>navigator.mediaDevices.getDisplayMedia</code> 方法实现提示用户选择和授权捕获展示的窗口，进而获取 stream (录制的屏幕音视流)。我们可以对 stream 进行转化处理，转成相对应的媒体数据，并将其数据存储。</p><pre><code class="language-js">var promise = navigator.mediaDevices.getDisplayMedia(constraints);
</code></pre><blockquote><p><a href="https://developer.mozilla.org/en-US/docs/Web/API/MediaDevices/getDisplayMedia">https://developer.mozilla.org/en-US/docs/Web/API/MediaDevices/getDisplayMedia</a></p></blockquote><ul><li><a href="https://juejin.cn/post/7028723258019020836">浅析Web录屏技术方案与实现</a></li><li><a href="https://juejin.cn/post/6896045087659130894">从0到1打造一个 WebRTC 应用</a></li><li><a href="https://juejin.cn/post/7010954456548245541">浅聊WebRTC视频通话</a></li></ul><p>📒 Go 1.18 Beta 1 已经正支持泛型</p><ul><li><a href="https://go.dev/blog/go1.18beta1">Go 1.18 Beta 1 is available, with generics</a></li><li><a href="https://go.dev/blog/why-generics">Why Generics?</a></li><li><a href="https://go.dev/play/?v=gotip">The Go Playground</a></li></ul><p>📒 <a href="https://juejin.cn/post/7041846339189080101">使用Golang、Gin和React、esbuild开发的Blog</a></p><p>📒 使用 patch-package 修复 npm 库的紧急问题</p><p>如果使用的 npm 库有 bug，可以使用 patch-package 创建一个补丁包。</p><p><a href="https://juejin.cn/post/7029310620952428558">工程化知识卡片 022: 质量保障篇之如何优雅某个 npm 库的紧急问题</a></p><p>📒 <a href="https://mp.weixin.qq.com/s/WWQa4kJXAblBkZS5zx3HBw">5 种有趣的 useEffect 无限循环类型</a></p><p>📒 <a href="https://github.com/you-dont-need/You-Dont-Need-JavaScript">用 CSS 来代替 JS 的实现</a></p><p>📒 <a href="https://juejin.cn/post/7027995169211285512">React18 新特性：transition</a></p><p>📒 <a href="https://juejin.cn/post/7038370502926139399">「2021」我给Vue.js生态贡献代码的这一年</a></p><p>⭐️ ⭐️ fiber：受到 Express 启发的 Web 应用框架，使用 Go 开发，与 Express 的 API 非常接近</p><pre><code class="language-go">package main

import &quot;github.com/gofiber/fiber/v2&quot;

func main() {
  app := fiber.New()

  app.Get(&quot;/&quot;, func(c *fiber.Ctx) error {
    return c.SendString(&quot;Hello, World 👋!&quot;)
  })

  app.Listen(&quot;:3000&quot;)
}
</code></pre><blockquote><p><a href="https://github.com/gofiber/fiber">https://github.com/gofiber/fiber</a></p></blockquote>]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[12月12日内容汇总]]></title>
            <link>https://your-docusaurus-test-site.com/frontend-weekly/blog/12月12日内容汇总</link>
            <guid>12月12日内容汇总</guid>
            <pubDate>Sun, 12 Dec 2021 00:00:00 GMT</pubDate>
            <description><![CDATA[📒 优雅获取 package.json 文件]]></description>
            <content:encoded><![CDATA[<p>📒 优雅获取 <code>package.json</code> 文件</p><p>这里需要注意一个问题，在 ES module 规范下无法直接引入 JSON 文件，只能通过 <code>require</code> 获取：</p><pre><code class="language-javascript">// ES module 模块
import React from &quot;react&quot;;
import { debounce } from &quot;lodash-es&quot;;
// JSON 模块只能通过 CJS 方式加载
const package = require(&quot;package.json&quot;);
</code></pre><p><code>import</code> 命令目前只能用于加载 ES 模块，现在有一个提案，允许加载 JSON 模块。<code>import</code> 命令能够直接加载 JSON 模块以后，就可以像下面这样写:</p><pre><code class="language-javascript">import configData from &#x27;./config.json&#x27; assert { type: &quot;json&quot; };
console.log(configData.appName);
</code></pre><blockquote><p><code>import</code> 命令导入 JSON 模块时，命令结尾的 <code>assert {type: &quot;json&quot;}</code> 不可缺少。这叫做导入断言，用来告诉 JavaScript 引擎，现在加载的是 JSON 模块</p></blockquote><p>除此之外，还可以使用第三方库 <code>read-pkg</code> 获取，原理是通过 <code>fs</code> 模块读取 <code>package.json</code> 文件，然后反序列化为 JS 对象：</p><pre><code class="language-javascript">import process from &#x27;node:process&#x27;;
import fs, {promises as fsPromises} from &#x27;node:fs&#x27;;
import path from &#x27;node:path&#x27;;
import parseJson from &#x27;parse-json&#x27;;
import normalizePackageData from &#x27;normalize-package-data&#x27;;

export async function readPackage({cwd = process.cwd(), normalize = true} = {}) {
    const filePath = path.resolve(cwd, &#x27;package.json&#x27;);
    const json = parseJson(await fsPromises.readFile(filePath, &#x27;utf8&#x27;));

    if (normalize) {
        normalizePackageData(json);
    }

    return json;
}
</code></pre><p>📒 如何覆盖某些元素的浏览器默认样式</p><p>很多元素，例如 <code>&lt;button&gt;</code>、<code>&lt;input type=&quot;text&quot; /&gt;</code>、<code>&lt;input type=&quot;checkbox&quot; /&gt;</code> 具有浏览器默认样式，有时候需要自己指定样式，如何覆盖浏览器默认样式，只需要下面一行代码：</p><pre><code class="language-css">input {
    -webkit-appearance: none;
}
</code></pre><p>📒 如何让 div 按比例缩放</p><p>有时希望 div 自适应页面宽度的时候，可以按比例缩放，这种情况下可以使用 <code>aspect-ratio</code> 属性：</p><pre><code class="language-css">div {
    aspect-ratio: auto 1 / 1;
}
</code></pre><p>推荐在 <code>ratio</code> 前面加 <code>auto</code> ，对于 input 等具有固有宽高比的替换元素将使用默认宽高比，否则就使用指定的宽高比。</p><blockquote><p>注意 <code>aspect-ratio</code> 兼容 Chrome &gt; 87 ，所有的 IE 浏览器都不兼容</p></blockquote><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/aspect-ratio">aspect-ratio - MDN</a></p><p>📒 <a href="https://www.smashingmagazine.com/2021/11/maintain-large-nextjs-application/">如何维护一个大型的 Next.js 应用</a></p><p>📒 Goober：CSS-in-JS 方案</p><p>这是一个 1 KB 大小的 CSS-in-JS 方案，可以替代 23 KB 的 styled-components 和 emotion 组合。而且如果你可以减少 goober 库 gzip 后的体积，他们还会奖励你美元。</p><blockquote><p><a href="https://github.com/cristianbote/goober">https://github.com/cristianbote/goober</a></p></blockquote><p>📒 使用支持 Tree Shaking 的包</p><p>如果可以的话，应尽量使用支持 Tree Shaking 的 npm 包，例如：</p><ul><li>使用 <code>lodash-es</code> 替代 <code>lodash</code> ，或者使用 <code>babel-plugin-lodash</code> 实现类似效果</li></ul><p>📒 win10 安装 nvm-windows</p><p>下载地址：</p><blockquote><p><a href="https://github.com/coreybutler/nvm-windows/releases">https://github.com/coreybutler/nvm-windows/releases</a></p></blockquote><p>用法跟 mac 上的 nvm 类似：</p><pre><code class="language-bash"># 安装 nodejs v16.13.1
$ nvm install 16.13.1

# 查看已安装的 nodejs 版本
$ nvm list

# 使用指定版本的 nodejs
$ nvm use 16.13.1

# 卸载某个版本的 nodejs
$ nvm uninstall 16.13.1
</code></pre><blockquote><p>个人猜测是通过修改环境变量实现 node 版本切换</p></blockquote><p>在使用的时候遇到两个问题：</p><ol><li>安装老版本 nodejs  的时候，node 安装成功，但是 npm 安装失败；</li><li>使用 <code>nvm use</code> 切换 node 版本的时候报错；</li></ol><p>第一个问题，给 nvm 配置淘宝镜像即可解决。找到 nvm 安装目录下的 <code>settings.txt</code> 文件，添加配置：</p><pre><code class="language-bash">node_mirror: https://npm.taobao.org/mirrors/node/
npm_mirror: https://npm.taobao.org/mirrors/npm/
</code></pre><p>第二个问题，首先检查 nvm 安装路径没有中文、没有空格，然后如果问题还在，那就是权限问题，使用管理员权限打开 cmd 即可正常切换。</p><p>📒 获取 worker 线程最大并发数</p><p>通过下面的只读属性获取用户计算机的逻辑内核数：</p><pre><code class="language-javascript">logicalProcessors = window.navigator.hardwareConcurrency
</code></pre><p>下面的代码中，为每一个逻辑内核创建一个 worker 线程，充分利用 CPU 资源：</p><pre><code class="language-javascript">let workerList = [];

for (let i = 0; i &lt; window.navigator.hardwareConcurrency; i++) {
  let newWorker = {
    worker: new Worker(&#x27;cpuworker.js&#x27;),
    inUse: false
  };
  workerList.push(newWorker);
}
</code></pre><p><a href="https://developer.mozilla.org/en-US/docs/Web/API/Navigator/hardwareConcurrency">Navigator.hardwareConcurrency - MDN</a></p><p>📒 <a href="https://juejin.cn/post/7039315081150087181">TypeScript类型中的逆变协变</a></p><p>📒 如何优雅引入 node 内置模块</p><p>在引用 node 内置模块的时候可以加 <code>node:</code> 前缀，比如：</p><pre><code class="language-javascript">import util from &#x27;node:util&#x27;;
import { promisify } from &#x27;node:util&#x27;;
import { spawn, exec } from &#x27;node:child_process&#x27;;
</code></pre><p>通过增加前缀，可以将 node 内置模块与其他第三方模块区分开：</p><pre><code class="language-javascript">import process from &#x27;node:process&#x27;;
import fs, {promises as fsPromises} from &#x27;node:fs&#x27;;
import path from &#x27;node:path&#x27;;
import parseJson from &#x27;parse-json&#x27;;
import normalizePackageData from &#x27;normalize-package-data&#x27;;
</code></pre><p>看到这边有同学会问，为啥 node 中可以使用 ES module，实际上现在 node 已经支持了 ES module ，只需要在 <code>package.json</code> 中设置如下字段即可：</p><pre><code class="language-javascript">{
    name: &quot;xxx&quot;,
    version: &quot;1.0.0&quot;
    type: &quot;module&quot;, // 默认 commonjs
}
</code></pre><p><a href="https://juejin.cn/post/7037270522236764167">从 vue-cli 源码中，我发现27行读取 json 文件有趣的 npm 包</a></p><p>📒 gradient-string: 在终端中输出漂亮的渐变色</p><p><img src="./gradient-string.png" alt="image"/></p><blockquote><p><a href="https://github.com/bokub/gradient-string">https://github.com/bokub/gradient-string</a></p></blockquote><p>📒 <a href="https://juejin.cn/post/6978654109893132318">手写系列-实现一个铂金段位的 React</a></p>]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[12月5日内容汇总]]></title>
            <link>https://your-docusaurus-test-site.com/frontend-weekly/blog/12月5日内容汇总</link>
            <guid>12月5日内容汇总</guid>
            <pubDate>Sun, 05 Dec 2021 00:00:00 GMT</pubDate>
            <description><![CDATA[📒 如何切换后端环境]]></description>
            <content:encoded><![CDATA[<p>📒 如何切换后端环境</p><p>在前端项目中，后端接口请求通常都通过 devServer 代理，这样解决了跨域问题。但是开发的时候经常需要切换后端环境，每次切换都要重启 devServer，这就导致每次都要重新构建，比较麻烦。</p><p>一种解决思路是，前端项目中后端接口地址使用 <strong>域名</strong>，在 <strong>系统 host 文件</strong> 中配置域名与 IP 地址的映射，这样每次切换后端环境，只需要修改系统 host 文件，然后在浏览器中刷新页面就可以实现切换。</p><p>但是每次手动修改 host 文件有点麻烦，可以使用 SwitchHost 工具，一键切换，非常方便。</p><p>📒 Vue 3 技术栈</p><ul><li>Vue3.2：核心库</li><li>Vite2.6：官方推出的基于 ESM 的构建工具</li><li>vue-router-next：Vue3 官方路由</li><li>pinia：官方推出的状态管理库</li><li>TypeScript：静态类型检查</li><li>Volar：Vue3 的 vscode 插件</li></ul><p>📒 Chrome 调试小技巧</p><p>在断点位置按 F9，可以一步一步往下执行，调试源码的时候查看调用栈特别有用。当然很多时候调用栈比较复杂，这时候通过 Performance 面板的火焰图看比较直观，火焰图的宽度代表执行耗时，火焰图的高度代表调用栈的深度。</p><p>📒 CommonJS 中的模块导出</p><p>CommonJS 规范中只有一种模块导出：<code>module.exports</code> ，而 <code>exports</code> 仅仅只是 <code>module.exports</code> 的引用而已</p><p>📒 推荐两个网站</p><ul><li><code>caniuse</code>：查询 api 兼容性</li><li><code>codeif</code>：变量命名</li></ul>]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[11月28日内容汇总]]></title>
            <link>https://your-docusaurus-test-site.com/frontend-weekly/blog/11月28日内容汇总</link>
            <guid>11月28日内容汇总</guid>
            <pubDate>Sun, 28 Nov 2021 00:00:00 GMT</pubDate>
            <description><![CDATA[📒 叮咚，您有一份「前端项目开发规范」待查收！]]></description>
            <content:encoded><![CDATA[<p>📒 <a href="https://juejin.cn/post/7033165869224034335">叮咚，您有一份「前端项目开发规范」待查收！</a></p><p>📒 <a href="https://juejin.cn/post/7033765500228206622">你了解 Browserslist 吗</a></p><p>📒 <a href="https://labuladong.github.io/algo/4/29/105/">回溯算法解题套路框架</a></p><p>📒 Golang 学习</p><ul><li><a href="https://gobyexample.com/">Golang 编程思维和工程实战</a></li><li>⭐️ <a href="https://gobyexample.com/">Go by example</a></li></ul><p>📒 React 文档翻译</p><ul><li><a href="https://reactjs.bootcss.com/learn/queueing-a-series-of-state-updates#challenges">Queueing a Series of State Updates</a></li><li><a href="https://github.com/reactjs/zh-hans.reactjs.org">React 中文文档</a></li></ul>]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[11月21日内容汇总]]></title>
            <link>https://your-docusaurus-test-site.com/frontend-weekly/blog/11月21日内容汇总</link>
            <guid>11月21日内容汇总</guid>
            <pubDate>Sun, 21 Nov 2021 00:00:00 GMT</pubDate>
            <description><![CDATA[📒 垂直居中小技巧]]></description>
            <content:encoded><![CDATA[<p>📒 垂直居中小技巧</p><p>相对父元素绝对定位，先向下偏移父元素高度的 <code>50%</code> ，在向上移动自身高度的 <code>50%</code> ：</p><pre><code class="language-css">.icon-common {
    position: absolute;
    top: 50%;
    transform: translateY(-50%);
}
</code></pre><p>📒 <a href="https://juejin.cn/post/7030441979645263909">Git 几点小知识技巧</a></p><p>📒 <a href="https://juejin.cn/post/7025809061660590087">工程化知识卡片 014: 发包篇之 package.json 中 main、export、module 的区别何在</a></p><p>📒 第三方库如何解决潜在的间接依赖不可控问题</p><p><code>lockfile</code> 对于第三方库仍然必不可少，像 <code>react</code> 、<code>next.js</code> 、<code>webpack</code> 等均有 <code>yarn.lock</code> 。第三方库的 <code>devDependencies</code> 必须锁定，这样 Contributor 可根据 lockfile 很容易将项目跑起来。第三方库的 <code>dependencies</code> 有可能存在不可控问题，可参考 <code>next.js</code> 的解决方案：</p><ol><li><p>将依赖版本在 <code>package.json</code> 中锁死</p><pre><code class="language-javascript">{
    &quot;dependencies&quot;: {
        &quot;@babel/runtime&quot;: &quot;7.15.4&quot;,
        &quot;@hapi/accept&quot;: &quot;5.0.2&quot;,
        &quot;@napi-rs/triples&quot;: &quot;1.0.3&quot;
    }
}
</code></pre></li><li><p>将部分依赖直接编译后直接引入，而非通过依赖的方式；</p></li></ol><p>📒 语义化版本</p><p><code>semver</code>，<code>Semantic Versioning</code> 语义化版本的缩写，文档可见 semver.org/，它由 <code>[major, minor, patch]</code> 三部分组成，其中</p><ul><li><code>major</code>: 当你发了一个含有 Breaking Change 的 API</li><li><code>minor</code>:  当你新增了一个向后兼容的功能时</li><li><code>patch</code>: 当你修复了一个向后兼容的 Bug 时</li></ul><p>对于 <code>~1.2.3</code> 而言，它的版本号范围是 <code>&gt;=1.2.3  &lt;1.3.0</code>
对于 <code>^1.2.3</code> 而言，它的版本号范围是 <code>&gt;=1.2.3  &lt;2.0.0</code></p><p>当我们 <code>npm i</code> 时，默认的版本号是 <code>^</code>，可最大限度地在向后兼容与新特性之间做取舍，但是有些库有可能不遵循该规则，我们在项目时应当使用 <code>yarn.lock/package-lock.json</code> 锁定版本号。</p><p>📒 Vue 3.2 响应式优化相关</p><p><code>Object.defineProperty</code> 处理深度嵌套对象需要进行递归，而 <code>Proxy</code> 同样也只能监听当前层级的对象，如果深度嵌套也需要递归的，所以才有了 <code>reactive</code> 和 <code>shallowReactive</code> 。</p><p>之前看了黄轶老师写的 Vue3.2 响应式优化，<code>Proxy</code>  实际上比 <code>Object.defineProperty</code> 要慢，Vue 2.x 是直接在初始化阶段就进行深度递归，而 Vue3 的响应式优化就体现在只有访问对象属性的时候，再递归响应式，也就是延迟处理子对象，所以在初始化阶段性能较好。</p><p>📒 手把手实现一个 babel 插件</p><p>这篇做的 demo 是一个简单的 babel-plugin-import
<a href="https://juejin.cn/post/6844903746804137991">深入Babel，这一篇就够了</a></p><p>这篇做的 demo 类似 Java 中的 lambok
<a href="https://juejin.cn/post/7012424646247055390">保姆级教学！这次一定学会babel插件开发！</a></p><p>📒 <a href="https://juejin.cn/post/7025524870842679310#heading-58">从 16 个方向逐步搭建基于 vue3 的前端架构</a></p><p>📒 <a href="https://juejin.cn/post/6844903869558816781">VuePress + Travis CI + Github Pages 全自动上线文档</a></p>]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[11月14日内容汇总]]></title>
            <link>https://your-docusaurus-test-site.com/frontend-weekly/blog/11月14日内容汇总</link>
            <guid>11月14日内容汇总</guid>
            <pubDate>Sun, 14 Nov 2021 00:00:00 GMT</pubDate>
            <description><![CDATA[📒 构建提效]]></description>
            <content:encoded><![CDATA[<p>📒 构建提效</p><ul><li>打包工具：webpack -&gt; rollup</li><li>生成 AST ：babel -&gt; acorn</li><li>语法转换：babel -&gt; swc</li><li>代码压缩：terser -&gt; esbuild</li></ul><p>📒 代码规范相关</p><ul><li>ESLint 用于代码规范检查，在开发阶段提前规避问题，提升代码健壮性</li><li>Prettier 用于代码风格校验，统一团队编码风格</li></ul><blockquote><p>实际上编写文档、单元测试、类型声明、tsconfig.json 、ESLint 、Prettier 、lint-staged 、husky 这些对实现功能上来说没有任何作用，但是可以保障代码交付质量</p></blockquote><p>📒 生成自增 ID ：</p><p>看到一个通过 generator 函数生成自增 ID 的方法：</p><pre><code class="language-javascript">function *customIdGenerator() {
  let i = 0;
  while (true) {
    yield i++;
  }
}
</code></pre><p>看了下其实还可以通过闭包实现：</p><pre><code class="language-javascript">function customIdGenerator() {
  let i = 0;
  return {
    next() {
      return i++;
    }
  }
}

const IDGenerator = customIdGenerator();
IDGenerator.next(); // 0
IDGenerator.next(); // 1
IDGenerator.next(); // 2
IDGenerator.next(); // 3
IDGenerator.next(); // 4
IDGenerator.next(); // 5
</code></pre><p>:::tip</p><p>注意：</p><p><code>++i</code> 是先加再作为表达式的值去赋值，相当于 <code>(i = i + 1)</code></p><p><code>i++</code> 是先把原来的值作为表达式的值赋值再加</p><p>:::</p><p>📒 专业名词</p><p>缓存命中
规则命中
增量构建</p><p>📒 Promise 四种常用工具方法</p><ul><li><code>Promise.all()</code> ：接收一个 <code>Promise</code> 数组，如果所有 <code>Promise</code> 都 <code>fulfilled</code> 则返回结果数组，只要有一个 <code>Promise</code> 变为 <code>rejected</code> ，则返回最先 rejected 的 <code>Promise</code> ，通常<strong>用于并发请求</strong>；</li><li><code>Promise.race()</code> ：接收一个 <code>Promise</code> 数组，race 意思就是比谁快，返回状态最先改变的 <code>Promise</code> ，不管成功还是失败，通常<strong>用于请求超时处理</strong>；</li><li><code>Promise.any()</code> ：接收一个 <code>Promise</code> 数组，返回最先 <code>fulfilled</code> 的 <code>Promise</code> ，如果没有 <code>Promise</code> 状态转为 <code>fulfilled</code> ，则抛出一个 <code>AggregateError</code> ；</li><li><code>Promise.allSettled()</code> ：接收一个 <code>Promise</code> 数组，在所有 <code>Promise</code> 状态改变（<code>fulfilled</code> 或者 <code>rejected</code>）之后返回结果数组。<code>Promise.allSettled</code> 适用于异步任务互相不依赖，<code>Promise.all</code> 适用于异步任务互相之间需要依赖其他任务的结果；</li></ul><p>📒 什么时候不能使用箭头函数</p><ul><li>需要函数提升时（箭头函数只能写成表达式形式）；</li><li>需要使用函数的 <code>this</code> 、<code>arguments</code> 、<code>prototype</code> 时；</li><li>需要使用命名函数时（箭头函数是匿名的）；</li><li>需要作为构造函数时（箭头函数不能作为构造函数）；</li><li>需要在对象方法中访问当前对象时;</li></ul><pre><code class="language-javascript">let obj = {
  a: 1,
  fn1: () =&gt; {
    console.log(this)
  },
  fn2: function() {
    console.log(this)
  }
}
obj.fn1(); // Window
obj.fn2(); // {a: 1, fn1: ƒ, fn2: ƒ} ，这是 this 的隐式绑定

const f1 = obj.fn1;
const f2 = obj.fn2;
f1(); // Window
f2(); // Window ，隐式绑定取决于谁来调用，谁调用就指向谁
</code></pre><p>使用箭头函数之所以会指向 <code>Window</code> 是因为箭头函数等价于下面的代码：</p><pre><code class="language-javascript">var that = this; // 直接使用闭包缓存 this
let obj = {
  a: 1,
  fn1: function() {
        console.log(that);
    }
}
</code></pre><p>在对象方法（例如 Vue Options API）的异步回调中经常会遇到 <code>this</code> 丢失的情况，一般会使用闭包进行缓存：</p><pre><code class="language-javascript">// 使用 _this 变量进行缓存
const _this = this;
api.get(&quot;/api/xxx&quot;, function(res) {
    _this.tableData = res;
})

// 除了使用闭包缓存 this ，还可以使用箭头函数
api.get(&quot;/api/xxx&quot;, (res) =&gt; {
    this.tableData = res;
})
</code></pre><blockquote><p>总结一下：箭头函数没有自己的 <code>this</code> ，没有 <code>argument</code> 对象，没有 <code>prototype</code> ，不能作为构造函数（用 new 调用会报错）。箭头函数会自动捕获上级词法作用域的 <code>this</code> ，并且箭头函数的 <code>this</code> 在声明的时候就已经确定了，不能通过 <code>call</code> 或者 <code>apply</code> 修改</p></blockquote>]]></content:encoded>
        </item>
    </channel>
</rss>